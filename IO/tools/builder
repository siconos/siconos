#!/usr/bin/env python

# ./builder -I/usr/local/include/Siconos/Kernel -I/usr/local/include/Siconos/Numerics -I/usr/include/libxml2 SiconosKernel.hpp

# we use pygccxml from Roman Yakovenko.
# http://sourceforge.net/projects/pygccxml/

import sys, os, getopt, re, itertools

from pygccxml import parser
from pygccxml import declarations

myname = sys.argv[0]
include_paths=[]
siconos_namespace = '::'

def usage():
    print '{0} [--namespace=<namespace>] -I<path> [-I<path> ...] header'.format(myname)


try:
    opts, args = getopt.getopt(sys.argv[1:], 'I:', ['help'])
except getopt.GetoptError, err:
    print str(err)
    usage()
    sys.exit(2)

for opt, arg in opts:
    if opt == '-I':
        include_paths += [ arg ]
    if opt == '--namespace':
        siconos_namespace = arg
    if opt == '--help':
        usage()
        sys.exit(0)


if len(args) <> 1:
    usage()
    sys.exit(1)        

input_header = args[0]    

config = parser.config_t( include_paths=include_paths )

decls = parser.parse( [input_header], config )
global_ns = declarations.get_global_namespace( decls )


def is_serializable(c):
    return 'serializable' in [ c.name for c in c.typedefs(allow_empty=True) ]

def unwanted(s):
    m = re.search('xml|XML|Xml|MBlockCSR|fPtr|SimpleMatrix|SimpleVector|SiconosVector|SiconosGraph|SiconosSet|DynamicalSystemsSet|SiconosSharedLibrary|numerics',s)
    return m != None

def name(t):
    if isinstance(t,declarations.class_t):
        return t.name
    elif isinstance(t,declarations.typedef_t):
        return t.decl_string[2:] # remove ::

# classes in siconos_namespace
class_names = dict()

print "// generated with the command : {0}".format(' '.join(sys.argv))


for type_ in filter(lambda c: c.parent.name == siconos_namespace,
                    itertools.chain(global_ns.classes(), global_ns.typedefs())):

    typedef = False

    if isinstance(type_,declarations.class_t):
        class_names[declarations.full_name(type_)] = type_
        class_ = type_
    elif isinstance(type_,declarations.typedef_t):
        try:
            typedef=True
            class_ = class_names['::' + str(type_.type)]
        except:
            class_ = None
    # with the serializabe tag
    # (could not find friend functions with pygccxml)
    if class_ is not None and \
           is_serializable(class_) and not \
           unwanted(class_.name) and \
           ( typedef or not \
             declarations.templates.is_instantiation(class_.name) ):

        # print registration macros depending on inheritance
        if class_.bases == []:
            print 'SICONOS_IO_REGISTER({0},'.format(name(type_))
        else:
            serializable_bases = \
                               reduce(lambda r,b:
                                      r + [b.related_class] if is_serializable(b.related_class)
                                      and b.related_class.parent.name == siconos_namespace
                                      else r, class_.bases, [])
            if len(serializable_bases) > 0:
                print 'SICONOS_IO_REGISTER_WITH_BASES({0},{1},'.format(name(type_),
                ''.join(['({0})'.format(c.name) for c in serializable_bases]))
            else:
                print 'SICONOS_IO_REGISTER({0},'.format(name(type_))

        variables = [ v.name for v in filter(lambda x: not 'void' in str(x._get_type()),class_.variables(allow_empty=True)) ]

        print '{0})'.format('\n'.join( '  ({0})'.format(vn) for vn in filter(lambda x: not unwanted(x), variables)))




