<?xml version="1.0" encoding=""?>
<!DOCTYPE html PUBLIC "-//Tigris//DTD XHTML 1.0 Transitional//EN" "http://style.tigris.org/tigris_transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content=""/>
  <title>Siconos call</title>
  <style type="text/css">
/* <![CDATA[ */ 
@import "css/readyset.css"; 
@import "css/inst.css";
/*  ]]>
 */
 </style>
  <link rel="stylesheet" type="text/css" href="css/print.css" media="print"/>
</head>

<body>

  The goal of this document is to give a global view of the siconos implementation.

  <h2>Global stack call.</h2>
 
  <ul>
    
    <li>main</li>
    <ul>
      <li>TS::computeOneStep</li>
      <ul>
	<li>TS::advanceToEvent</li>
	<ul>
	  <li>TS::computeInitialResidu</li><ul>
	    <li>Relation::computegh</li>
	    <li>ds::updatePlugins (Warning : Used only for the FirstOrderNonLinearDS)</li>
	    <li>OSI::computeResidu</li><ul>
	      <li>for all ds, ds::residuFree <-- W(v-vold)-h Fl_k</li>
	      </ul>
	    </ul>
	  <li>TS::prepareNewtonIteration</li>
	  <ul>
	    <li>Moreau::computeW</li><ul>
	      <li>Lagrangian : WMap[ds]<-- M-h*theta C-hh*theta*thetaK </li>
	      <li>Newton Euler : Error Do Nothing</li>
	      </ul>
	    <li>Relation::computeJachg</li>
	    <li>DS::preparStep</li>
	    <li>Relation::preparNewtonIteration</li>
	    do something only for the FirstOrderType2R!
	  </ul>
	  <li>TS::computeFreeState</li>
	  <ul>
	    <li>Moreau::ComputeFreeState.</li>
	    <ul>
	      <li>Compute the velocity free.</li>
	      Lagrangian : using WMap<br>
	      NewtonEuler: using ds::luW (Error, it contains only Mass matrix,it miss elements)
	    </ul>
	  </ul>
	  <li>TS::computeOneStepNSProblem</li>
	  <ul>
	    <li>OSNSP::compute</li><ul>
	      <li>OSNSP::Precompute</li>
	      <li>Numerics::Solver</li>
	      _z,_w <-- solution
	      <li>OSNSP::PostCompute</li>
	      UR::y(ie Interaction::y) <-- _z,_w 
	      </ul>
	  </ul>
	  <li>TS::update</li>
	  <ul>
	    <li>TS::updateInput</li>
	    <ul>
	      <li>Interaction,Relation::computeInput</li>
	      compute B*Lambda, the inpute of the DS
	    </ul>
	    <li>OSI::updateState</li>
	     V_{k+1} <-- W^{-1}p + V_free<br>
	    misaj de q <br>  
	    NewtonEuler, updateT and update dotq
	    <li>TS::updateOutput</li><ul>
	      <li>Interaction,Relation::computeOutput</li>
	      <li>computation of ydot from qdot and jachq</li>
	      computeh and sometime computeJachq.
	      </ul>
	  </ul>
	</ul>
      </ul>
      <li>TS::nextStep</li>
      <ul>
	<li>TS::processEvent</li>
	<ul>
	  <li>EventsManager::processEvents</li>
	  <ul>
	    <li>EventsManager::OptimizedProcessEvent</li>
	    <ul>
	      <li>nextEvent::process(simu)</li>
	      <ul>
		<li>Simulation::saveInMemory</li>
	      </ul>
	      <li>simulation::updateIndexSets</li>
	      <li>TD::increment()</li>
	      set the step size ??
	      <li>ETD::setTime</li><ul>
		<li>nextEvent = followingEvent</li>
		</ul>
	      <li>EventManager::update</li>
	    </ul>
	  </ul>
	  <li>DS::endStep</li>
	</ul>
      </ul>
    </ul>
  </ul>
	<h2>TS::newtonSolve</h2>
<ul>
  <li>TS::newtonSolve</li><ul>
    <li>TS::computeInitialResidu</li>
    <ul>loop
      <li>TS::prepareNewtonIteration</li>
      <li>TS::computeFreeState</li>
      <li>TS::computeOneStepNSProblem</li>
      <li>TS::update</li>
      <li>TS::newtonCheckConvergence</li>
      <ul>
	<li>OSI::computeResidu</li>
      </ul>
      <li>TS::saveYandLambdaInMemory</li>
    </ul>
  </ul>
</ul>
<h2>TSProj::newtonSolve</h2>
<ul>
  <li>TSProj::newtonSolve</li><ul>
    <li>TS::newtonSolve</li>
    <li>R::computeJachq</li>
    <li>R::computeh</li>
    <li>TS::computeOneStepNSProblem</li>
    <li>q normalized</li>
    <li>update T</li>
    <li>update dotq</li>
    <li>TS::updateOutput (in view of updated ydot)</li>
  </ul>
</ul>

<h2>Building of the numerics matrix.</h2>
<p>In cuurent version the memory management about the matrices involve the following datas:</p>
<ul>
  <li>OSNSP::_M a SP::OSNSMatrix that can be dense or sparseBlock.</li>
  <li>OSNSP::_M.M1 a siconosMatrix used for dense storage.</li>
  <li>OSNSP::_M.M2 a BlockCSRMatrix used for sparseBlock.</li>
  <li>OSNSP::_M.numericsMat a numerics matrices</li>
  <li>At each edge and vertex is attach the 'unitaryBlock' that is a dense matrix.</li>
</ul>
<p>The dense matrix M1 is build from the block graph by copy. The block matrix M2 is buuilt by copy only the pointer of block.</p>
<p>If necessary (topo->hasChange and first step of Newton ?) the numerics matrix must re-built. The OSNSP::preCompute manages theses matrices.</p>

<ul>
  <li>OSNSP::compute</li><ul>
    <li>LinearOSNSP::preCompute</li><ul>
      <li>OSNSP::updateUnitaryBlocks</li><ul>
	The blocks attach to the graph are built.
	<li>OSNSP::computeDiagUnitaryBlocks</li>
	<li>OSNSP::computeUnitaryBlocks</li>
	</ul>
      <li>OSNSMatrix_M::fill(indexset)</li><ul>
	<li>OSNSMatrix::updateSizeAndPositions(dimColumn, indexSet);</li>
	<li>if dense : memory allocation(M1) and setBlock(copy).</li>
	<li>if block : build block matrix(M2) and M2->fill(indexSet) set pointer</li>
	<li>OSNSMatrix::convert</li><ul>
	  <li>OSNSMatrix::numericsMatrix : build the numericsMatrix OSNSP::_M.numericsMat</li>
	</ul>
	
      </ul>
      <li>restore prev lambda and Y</li>
      <li>OSNSP::computeq</li>
      <ul>
	
	<li>OSI->computeFreeOutPut</li>
	      <ul>
		<li>Yp=jachqT*Vfree</li>
		<li>Yp+=e yold</li>
	      </ul>
	      
	<li>q=Yp</li>
      </ul>
      </ul>
    <li>OSNSP::postCompute</li>
    </ul>
  </ul>

<h2>Case of GenericMechanical Problem:</h2>
<ul>
  <li>GMP::updateUnitaryBlocks</li><ul>
    <li>freeGenericMechanicalProblem: freeGMP of Numerics</li>
    <li>buildEmptyGenericMechanicalProblem: build empty Numerics problem</li>
    <li>OSNSP::updateUnitaryBlocks</li><ul>
      <li>GMP::computeDiagonalUnitaryBlock</li><ul>
	<li>add the prb in the Numerics structure (GMP)</li>
	<li>LinearOSNSP::computeDiagonalUnitaryBlock</li><ul>
	  <li>build and get currentUnitaryBlock from the graph</li>
	  <li>UR::getLeftUnitaryBlockForDS</li><ul>
	    <li>(NewtonEuler) R::jachqT (overLoaded for FC3D)</li>
	    <li>(Lagrangian) R::jachq</li>
	  </ul>
	  <li>compute currentUnitaryBlock </li>
	</ul>
      </ul>
      <li>GMP::computeUnitaryBlock</li>
    </ul>
  </ul>
</ul>
</body>

</html>
