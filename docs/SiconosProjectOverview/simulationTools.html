<!DOCTYPE html PUBLIC "-//Tigris//DTD XHTML 1.0 Transitional//EN" "http://style.tigris.org/tigris_transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type"
 content="text/html; charset=iso-8859-1"/>
  <title>Simulation component</title>
  <style type="text/css">
/* <![CDATA[ */ 
@import "css/readyset.css";
@import "css/inst.css";
/*  ]]>
 */
 </style>
  <link rel="stylesheet" type="text/css" href="css/print.css"
 media="print"/>
</head>
<body>
<div class="app">
<div class="readyset">
<h2>Kernel Components &gt; Simulation<br/>
</h2>
<div id="releaseinfo">
<h3>Release Information</h3>
<table class="axial" border="1" cellpadding="3" cellspacing="2">
  <tbody>
    <tr>
      <th>Project:</th>
      <td><a href="index.html">Siconos</a></td>
    </tr>
    <tr>
      <th>Internal Release Number:</th>
      <td>1.0</td>
    </tr>
    <tr>
      <th>Last update:</th>
      <td>November 29, 2006</td>
    </tr>

    <tr>
      <th>Related Documents:</th>
      <td>
      <div> <a href="design.html">Design</a>&nbsp;</div>
      <div> <a href="glossary.html">Glossary</a></div>
      </td>
    </tr>
  </tbody>
</table>
</div>
<!-- /releaseinfo -->
<!-- /processimpact -->
<div id="SimulationComponent">&nbsp;&nbsp; &nbsp;&nbsp; <br />
<h3>Simulation component<br />
</h3>
<table>
  <caption><br />
  </caption> <tbody>
    <tr>
      <th><b>What for?</b></th>
      <td>all classes/objects to define a simulation to solve the
pre-defined NonSmoothDynamicalSystem. </td>
    </tr>
    <tr>
      <th><b>Feature sets:</b></th>
      <td><a href="features.html#F-2.001">F-2001.</a> and <a
 href="features.html#F-2.100">F-2.100</a>, <a
 href="features.html#F-2.106">F-2.106</a>;<br />
      </td>
    </tr>
    <tr>
      <th><b>Depencies:</b></th>
      <td><a href="glossary.html#Siconos/Numerics">Siconos/Numerics</a>,
      <a href="inputOutput.html">Input-output </a>(xml), <a
 href="modelingTools.html">Modeling</a><br />
      </td>
    </tr>
    <tr>
      <th><b>Interfaces:</b></th>
      <td> <a href="glossary.html#Siconos/Numerics">Siconos/Numerics</a></td>
    </tr>
    <tr>
      <th><b>Sources directory name:</b></th>
      <td>Kernel/src/simulationTools </td>
    </tr>
  </tbody>
</table>
<br />
To find more details on objects described in this section, see
<a href="http://siconos.gforge.inria.fr/Doxygen/index.html">Doxygen</a>
documentation of Siconos/Kernel. <br />
<br />

<h3><a class="anchor" name="docSimu">Siconos Simulation and related objects</a></h3><a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a> object is used to describe how a previously defined <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d2d/classNonSmoothDynamicalSystem.html">NonSmoothDynamicalSystem</a> will be computed. <br>
<p>
So before starting any simulation process, you need to have a complete non smooth dynamical system (roughly some DynamicalSystems and some Interactions), attached to a <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/d18/classModel.html">Model</a>. Then the key points of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a> are:<ul>

<li>the description of a time discretisation (see <a class="el" href="docSimu.html#docSimuTD">Time Discretisation</a>)</li><li>how the dynamical systems are integrate (see <a class="el" href="docSimu.html#docSimuOSI">One Step Integrators</a>)</li><li>how the non smooth problem is written and solved (see <a class="el" href="docSimu.html#docSimuOSNS">One Step Non Smooth Problems</a>)</li></ul>
<p>
Above all these points, a global strategy must be defined. At the time, two possibilities exist in Siconos:<ul>
<li><a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html">TimeStepping</a> scheme</li><li><a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> algorithm Those two types are derived classes of the base one, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a>.</li></ul>

<p>
<div align="center">
<img src="classSimulation.png" alt="classSimulation.png">
</div>

For a complete description of Time Stepping and Event Driven algorithm see the User Manual related pages at <a href="http://siconos.gforge.inria.fr/GettingStarted//docSimuMoreauTS.html"> Moreau's Time Stepping scheme </a> or <a href="http://siconos.gforge.inria.fr/GettingStarted//docSimuED.html"> Event Driven algorithm</a>

<p>
Finally to build a <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a>, four steps are required:<ul>
<li>choose a strategy, the type of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a>: build a <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html">TimeStepping</a> or an <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> object</li><li>build a <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html">TimeDiscretisation</a> object</li><li>build one or more <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d8/d72/classOneStepIntegrator.html">OneStepIntegrator</a> objects</li><li>build one or more <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/df/db1/classOneStepNSProblem.html">OneStepNSProblem</a> objects</li></ul>

<p>
and so, the C++ code looks like: <div class="fragment"><pre class="fragment"><span class="comment">// Prerequisite: </span>
<span class="comment">// a Model*, say m, that holds a NonSmoothDynamicalSystem* named nsds. </span>
<span class="comment">//</span>
<span class="comment">// Step 1: choose the strategy, build the Simulation and link it to the Model</span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html">TimeStepping</a> * s = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html">TimeStepping</a>(m); 

<span class="comment">// or</span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> * s = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a>(m);

<span class="comment">// Step 2: the time discretisation, linked with the Simulation when built. </span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html">TimeDiscretisation</a> * td = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html">TimeDiscretisation</a>(...,s)


<span class="comment">// Step 3: OneStepIntegrators; applied to DynamicalSystems that belong to nsds.</span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/de1/classMoreau.html">Moreau</a> * integrator = new <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/de1/classMoreau.html">Moreau</a>(someDS,...,s) ; 
<span class="comment">// or</span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/dbb/classLsodar.html">Lsodar</a> * integrator = new <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/dbb/classLsodar.html">Lsodar</a>(someDS,s);

<span class="comment">// Step 4: OneStepNSProblems; applied to all the Interactions of the nsds.</span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/df/db1/classOneStepNSProblem.html">OneStepNSProblem</a> * lcp = new <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a>(s, ...)

</pre></div> Then, from this point the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/d18/classModel.html">Model</a> is complete and the simulation process can start. Its development depends strongly on the chosen strategy and will then be detailed in the corresponding sections (see <a class="el" href="docSimuMoreauTS.html">Moreau's Time Stepping scheme</a> or <a class="el" href="docSimuED.html">Event Driven algorithm</a>).<br>
 Warning: it is important to make a clear difference between the building of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a>, which is part of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/d18/classModel.html">Model</a>, and the computation process which consists mainly in some calls to specific functions of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a>.<h3><a class="anchor" name="docSimuIntro">

Main components of a Simulation</a></h3>
<h3><a class="anchor" name="docSimuTD">
Time Discretisation</a></h3>
The discretization scheme is characterized by a vector of size nSteps+1, denoted tk, that handles the values at each time-step, nSteps being the number of time steps. At the time, only constant time-step (denoted h) time discretisation is available. <br>
 A <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html">TimeDiscretisation</a> must be linked to one and only one <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a> (required parameter of any constructor). The initial time value is always given by the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/d18/classModel.html">Model</a> that holds the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a>, while the final time value is an optional parameter of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/d18/classModel.html">Model</a>. Thus depending on the constructor you use, you may need to give the time-step, the final time ... Just take care to avoid redundant or conflicting information. See the constructors list in the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html">TimeDiscretisation</a> class documentation for full details.<p>

Example: <div class="fragment"><pre class="fragment"><a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/d18/classModel.html">Model</a> * m = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/d18/classModel.html">Model</a>(t0); <span class="comment">// only initial time is provided</span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a> * s = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html">TimeStepping</a>(m); <span class="comment">// s belongs to the Model m</span>

<span class="keywordtype">double</span> h = ...;
<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nSteps = ...;
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html">TimeDiscretisation</a> * td = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html">TimeDiscretisation</a>(h, nSteps);
<span class="comment">// tk and final time will be automatically computed. </span>

</pre></div><h3><a class="anchor" name="docSimuOSI">
One Step Integrators</a></h3>
<a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d8/d72/classOneStepIntegrator.html">OneStepIntegrator</a> ("OSI") class defines how Dynamical Systems will be integrated over a time-step. Two types of integrators are available at the time in the platform: <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/de1/classMoreau.html">Moreau</a> (see details in docSimuMoreau) and <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/dbb/classLsodar.html">Lsodar</a>. <br>
 To build an OSI, you need to provide a set of DynamicalSystems (and possibly a set of Interactions) and some specific values depending on the type of the integrator. Moreover, the "size of the memory" (variable sizeMem) can be set: it concerns the number of time steps for which states values are saved, but at the time no multi-steps integrators are available in Siconos, so keep default value, 1.<p>
main functions:<ul>

<li>integrate(t0, t, ...): integrate the system between t0 and t.</li><li>updateState(...): computes DynamicalSystems states values</li></ul>
<h4><a class="anchor" name="docSimuOSIMoreau">
Moreau</a></h4>
Integration thanks to a theta-method. See docSimuMoreau for a full description.<p>
Main variables: <img class="formulaInl" alt="$ \theta $" src="form_162.png"> (a double) and <img class="formulaInl" alt="$ W $" src="form_174.png"> (a matrix of double). One value of each parameter is attached to each <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/da1/classDynamicalSystem.html">DynamicalSystem</a> concerned by the OSI through a map (STL). For example: <div class="fragment"><pre class="fragment"><span class="comment">// allDS is a set of DynamicalSystems : ds1, ds2 ...</span>

<span class="comment">// s is a Simulation*</span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/de1/classMoreau.html">Moreau</a> * integrator = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/de1/classMoreau.html">Moreau</a>(allDS, 0.5, s);
<span class="comment">// all values of theta are initialized to 0.5</span>

<span class="keywordtype">double</span> theta = integrator-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/de1/classMoreau.html#5c4e60f6a35b85cd04214f6a079a97a1">getTheta</a>(ds1);

<span class="comment">// returns the value of theta for the dynamical system ds1.</span>

<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d4/dee/classSiconosMatrix.html">SiconosMatrix</a> * W = integrator-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/de1/classMoreau.html#f7e70863b51779b208c2896e595b012e">getW</a>(ds1);
<span class="comment">// W is a SimpleMatrix *, that represents the W linked to ds1. </span>
</pre></div><h4><a class="anchor" name="docSimuLsodar">
Lsodar</a></h4>
This class is an interface for LSODAR, odepack integrator (see <a href="http://www.netlib.org/alliant/ode/doc">http://www.netlib.org/alliant/ode/doc</a>). <br>

 "Lsodar solves problems dy/dt = f with full or banded Jacobian and automatic method selection, and at the same time, it finds the roots of any of a set of given functions of the form g(t,y).  This is often useful for finding stop conditions or points at which switches are to be made in the function f". <br>
 In Siconos, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/dbb/classLsodar.html">Lsodar</a> is used for <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> algorithm, to integrate the dynamics with stops at new non-smooth events (violation of a constraint). That will be detailed in <a class="el" href="docSimuED.html">Event Driven algorithm</a>.<p>
Construction: <div class="fragment"><pre class="fragment"><span class="comment">// allDS is a set of DynamicalSystems and s a Simulation*</span>

<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/dbb/classLsodar.html">Lsodar</a> * integrator = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/dbb/classLsodar.html">Lsodar</a>(allDS,s);
</pre></div> At the time, all specific parameters of <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/dbb/classLsodar.html">Lsodar</a> are set by default, but you can set them thanks to set functions. See <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/dbb/classLsodar.html">Lsodar</a> class doxygen documentation for details.<h3><a class="anchor" name="docSimuOSNS">
One Step Non Smooth Problems</a></h3>

Considering a set of Interactions, the role of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/df/db1/classOneStepNSProblem.html">OneStepNSProblem</a> ("OSNS") is to write in a "pleasant" form the non smooth problem and then to solve it. So, the main variables of this class are:<ul>
<li>a type: the form of the problem, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a>, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dd/da1/classFrictionContact.html">FrictionContact</a>, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/d99/classQP.html">QP</a> and <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/da6/classRelay.html">Relay</a> (the two last ones are not fully implemented and so not usable).</li><li>a set of Interactions (actually a link to those of the previously built <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d2d/classNonSmoothDynamicalSystem.html">NonSmoothDynamicalSystem</a>)</li><li>a solver </li></ul>

<h4><a class="anchor" name="docSimuSolvers">
Non smooth solvers</a></h4>
Solvers algorithms are implemented in Numerics package and Kernel <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/de/d9d/classSolver.html">Solver</a> class is just an interface to those algorithms. The possible solvers are:<ul>
<li>LexicoLemke (maxIter)</li><li>NLGS (Non Linear Gauss Seidel) (tolerance, maxIter)</li><li>NSQP (Non Smooth Quadratic Programming) (tolerance)</li><li><a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/d99/classQP.html">QP</a> (tolerance)</li><li>CPG (Conjugate Projected Gradient) (tolerance, maxIter)</li><li>Latin (tolerance, maxIter, searchDirection)</li></ul>

<p>
For each of them, the required parameters are indicated between parenthesis. Their default values are:<ul>
<li>maxIter (maximum number of iterations): 101</li><li>tolerance: 0.0001</li><li>normType: "max"</li><li>searchDir: 0.6</li></ul>
<p>
Obviously, depending on the problem type, some solvers fit more than others.<h4><a class="anchor" name="docSimuLCP">
LCP formalization and solving</a></h4>
A Linear Complementarity Problem (<a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a>) is defined by : <p class="formulaDsp">

<img class="formulaDsp" alt="\begin{eqnarray*} w = Mz+q \\ w \geq 0, z \geq 0, z^{T} w = 0 \end{eqnarray*}" src="form_180.png">
<p>
 where <img class="formulaInl" alt="$ w \in R^{n} $" src="form_175.png"> and <img class="formulaInl" alt="$ z \in R^{n} $" src="form_176.png"> are the unknowns and <img class="formulaInl" alt="$ M \in R^{n \times n } $" src="form_177.png"> and <img class="formulaInl" alt="$ q \in R^{n} $" src="form_178.png">.<br>
<p>
Thus, "formalizing" a <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a> consists in writing M matrix and q vector (functions <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html#527d364513bea5211553c26702d1f775">assembleM </a> and <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html#cfa63973b4a7743ed6f2b6442e7f88e0">computeQ </a>).<h4><a class="anchor" name="docSimuFriction">

Friction-Contact Non Smooth Problem</a></h4>
In Siconos, a Friction Contact is written as a <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a> like above: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} w = Mz+q \\ w \geq 0, z \geq 0, z^{T} w = 0 \end{eqnarray*}" src="form_180.png">
<p>
 plus a Coulomb-Friction law.
<br/>            
<h3><a class="anchor" name="docSimuEDindexSet">
Unitary Relations and Index Sets</a></h3>
Warning: reading this section is only useful if you need more understanging and details in <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> algorithm.<p>
<b>classes:</b> <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d0b/classUnitaryRelation.html">UnitaryRelation</a>, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/d15/classUnitaryRelationsSet.html">UnitaryRelationsSet</a><p>
The <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a> class has a specific member named indexSets, which is a vector (STL) of <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/d15/classUnitaryRelationsSet.html">UnitaryRelationsSet</a>.<h3><a class="anchor" name="docSimuUR">
Unitary Relation definition</a></h3>
Remember that each <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/d0c/classInteraction.html">Interaction</a> has two specific local variables, named y (output) and <img class="formulaInl" alt="$ \lambda $" src="form_102.png">, used to define the non-smooth behavior of the system. The size of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/d0c/classInteraction.html">Interaction</a> was defined as the one of y vector. Roughly speaking y corresponds to a set of constraints applied to the system, like in Linear Relations (<a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/db1/classLinearTIR.html">LinearTIR</a>) where: <img class="formulaInl" alt="$ y = CX + FU + D \lambda + e $" src="form_335.png"><p>
In that case, if D is diagonal, the previous set is equivalent to n independent scalar equations, n being the size of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/d0c/classInteraction.html">Interaction</a>: <img class="formulaInl" alt="$ y_i = C_i X +F_i U + d_{ii} \lambda_i+e_i $" src="form_336.png"><p>
So a model with n Interactions of size one with the n relation <img class="formulaInl" alt="$ y_i = \cdots $" src="form_340.png"> will be equivalent.<br>
 But if D is not diagonal, all relations are to be treated all together, in one block. The same think occurs for a friction problem, where the minimum block size is 2 or 3 (for 2 or 3 dimensional friction) because we need to consider normal and tangential part(s) of y. <br>
<p>
So to avoid confusion during <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a> process, we define <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d0b/classUnitaryRelation.html">UnitaryRelation</a> object, which "cuts" the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/d0c/classInteraction.html">Interaction</a> and its vectors into the smallest possible blocks. The size of these blocks corresponds to the non-smooth law size. <br>
<p>
What is important is that during <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a> process we do not handles Interactions but UnitaryRelations. From the user point of view, that did not change anything and since Interactions and UnitaryRelations are linked you can goes on using Interactions in a transparent way. But if you intend to use or have a look into IndexSets, you should know what they handle, UnitaryRelations.<h3><a class="anchor" name="docSimuIndexSets">
Index Sets definition</a></h3>
As suggested at the end of the previous section, an index set is a set of unitary relations. <br>
 Thus we define <img class="formulaInl" alt="$ I_0 $" src="form_337.png"> as the sets of all the unitary relations of the system, which more or less corresponds to the set of all the Interactions of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d2d/classNonSmoothDynamicalSystem.html">NonSmoothDynamicalSystem</a>. <br>
 For example, in a contact-problem, that represents all the unilateral constraints (active or not). The set <img class="formulaInl" alt="$ I_0 $" src="form_337.png"> is saved in the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/d18/classTopology.html">Topology</a> of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d2d/classNonSmoothDynamicalSystem.html">NonSmoothDynamicalSystem</a>, and build during <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html">Simulation</a> initialization. From this one, we define all the other sets: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ I_i = \{ UR\in I_{i-1} , y_{ur}[i-1] = 0 \} \]" src="form_338.png">
<p>
 with UR=UnitaryRelation, and <img class="formulaInl" alt="$ y_{ur}[i-1] $" src="form_339.png"> the i-1 derivative of the relation of ur.

<h2><a class="anchor" name="docSimuED">Event Driven algorithm</a></h2><h3><a class="anchor" name="docSimuEDPrinciple">
General Principle</a></h3>
The principle of the event-driven is based on the time-decomposition of the dynamics in modes, time-intervals where the dynamics is smooth, and discrete events, times where the dynamics are nonsmooth. From the numerical point of view, the event-driven scheme use the decomposition in time of the dynamics in order to<ul>
<li>detect and solve the non smooth dynamics at events with a reinitialization rule of the state,</li><li>integrate the smooth dynamics between two events with any ODE solvers with root-findings and possibly bilateral constraints on the state.</li></ul>
<h3><a class="anchor" name="docSimuEDImplementation">
Event Driven implementation</a></h3>
<b>Related</b> <b>classes:</b> <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a>, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dda/classEventsManager.html">EventsManager</a>, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d5e/classTimeDiscretisationEvent.html">TimeDiscretisationEvent</a>, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/df/df0/classNonSmoothEvent.html">NonSmoothEvent</a>, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/dbb/classLsodar.html">Lsodar</a>.<br>
 The figure below represents the class architecture for <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> simulation.<p>
<div align="center">
<img src="classEventDriven.png" alt="classEventDriven.png">
</div>
 <h3><a class="anchor" name="docSimuEDintegrate">
Integration of the smooth dynamics</a></h3>
Between events, the dynamics are integrated thanks to <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/dbb/classLsodar.html">Lsodar</a> algorithm and with the function EventDriven::integrate. <br>
 Considering two given functions f(x,t) and g(x,t), a call to integrate(tinit, tend, tout, iout) results in the integration of the function f(x,t) between tinit and tend, and search for roots of the function g(x,t). If roots are found, integration stops, and last time is saved in tout. <br>
 The in-out parameter iout is an indicator that must be set to 1 at first call. If no root was found, it is equal to 2 if so to 3. <br>
 Thus for an <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> simulation:<ul>
<li>the dynamics of all the concerned DynamicalSystems is rewritten as <img class="formulaInl" alt="$ \dot = f(x,t) $" src="form_334.png"></li><li>the relations are used to defined the g(x,t) functions</li></ul>
<p>
Once again the proper definition of f and g depends on the system type, so for details see <a class="el" href="docSimuED.html#docSimuEDDetails">Event Driven algorithm for Lagrangian systems</a>.<h3><a class="anchor" name="docSimuEDEvent">
Events</a></h3>
In Siconos the object <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d5/da5/classEvent.html">Event</a> just handle a type (see below) and a long int which corresponds to the time of occurrence of the event. A process function is also defined, which action depends on the event type.<p>
The possible types (derived classes) are:<ul>
<li><a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d5e/classTimeDiscretisationEvent.html">TimeDiscretisationEvent</a>: event that corresponds to user-defined time discretisation points. These events are created and schedule when the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> simulation is initialized. Process function call results in :<ul>
<li>update (compute) output for all the concerned Interactions</li><li>save current values (DynamicalSystems states and Interactions input/output) in memory vectors. Last saved values become initial values for next integration.</li></ul>
</li></ul>
<p>
<ul>
<li><a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/df/df0/classNonSmoothEvent.html">NonSmoothEvent</a>: "points" where the dynamics are non smooth and which required a special treatment. These events are detected thanks to a roots-finding algorithm, and corresponds to violation of some given constraints (relation). The action of the process function is roughly (the full process depends on the system type and is described in <a class="el" href="docSimuED.html#docSimuEDDetails">Event Driven algorithm for Lagrangian systems</a>):<ul>
<li>update (compute) output for all the concerned Interactions</li><li>update the index sets</li><li>formalize and solve one or more non-smooth problems</li><li>save current values (DynamicalSystems states and Interactions input/output) in memory vectors. Last saved values become initial values for next integration.</li></ul>
</li></ul>
<h3><a class="anchor" name="docSimuEDManager">
The Events manager</a></h3>
To handle all the events, a specific object is built: the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dda/classEventsManager.html">EventsManager</a>. It belongs to the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> class and holds two eventsContainers (sets of Events):<ul>
<li>pastEvents: for all the Events that has already been treated</li><li>unProcessedEvents: for the future events, already scheduled but not treated We also denote "currentEvent" the last processed event, which corresponds to the initial point of the current integration, and "nextEvent" the event following "currentEvent".</li></ul>
<p>
The events manager is initialized with time-discretisation events, from the user time-discretisation. Then, each time a new event is detected (added by user or when a root is found during integration) it is scheduled in the manager. <br>
 The manager has also a <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dda/classEventsManager.html#fb07e21cdfca36b9166236ee0c0cce19">processEvents </a> function, which moves currentEvent to past events set, processes nextEvent and prepare the next step. <br>
<p>
Other useful functions are:<ul>
<li><a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dda/classEventsManager.html#36ae82fb56a5a2d321f779abe28847d7">getCurrentTime </a>, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dda/classEventsManager.html#4cc7f51436ffb3a2cd1e9d0b7475a339">getNextTime </a></li><li><a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dda/classEventsManager.html#e002d9471830f96ae13fb6561ee5ac1d">scheduleEvent </a>: to add a new event in the manager. This function is the only way to create and add new events in your simulation; since you are not allowed to straightforward create an <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d5/da5/classEvent.html">Event</a> and add it in the manager.</li><li><a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dda/classEventsManager.html#e3d2bfab3dc4b50272a554c2c44a1a1d">removeEvent </a> to delete an event ...</li></ul>
<h3><a class="anchor" name="docSimuEDProcess">
The Simulation process</a></h3>
Thus, a general step of integration for <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> will looks like: "While there are some events in the unProcessedEvents set, integrate the smooth dynamics between current and next event and then process with the behavior at event". Or: <div class="fragment"><pre class="fragment"><a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> * s = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a>(myModel);

s-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html#aeec1ffcd98472ba0642f00710db7d0e">initialize</a>();

<span class="comment">// We get the events manager</span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dda/classEventsManager.html">EventsManager</a> * eventsManager = s-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html#8c2f223c397df7101bee9da3793a8f7c">getEventsManagerPtr</a>();

<span class="comment">// while there are some events ...</span>
<span class="keywordflow">while</span>(eventsManager-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dda/classEventsManager.html#ba90bbb41e320155d7a57e3f6c419038">hasNextEvent</a>())
{
  <span class="comment">// integrate between current and next event</span>
  s-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html#9af302469af533f599fc4ddcd5cad79c">advanceToEvent</a>();
  <span class="comment">// solve the non-smooth dynamics, if necessary ...</span>
  eventsManager-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dda/classEventsManager.html#fb07e21cdfca36b9166236ee0c0cce19">processEvents</a>();
}

<span class="comment">// Or in one step:</span>
<span class="keywordflow">while</span>(eventsManager-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dda/classEventsManager.html#ba90bbb41e320155d7a57e3f6c419038">hasNextEvent</a>())
{
 s-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html#1c9338017d8aed285ee7f80313ad81cb">computeOneStep</a>();
}
</pre></div><h3><a class="anchor" name="docSimuEDDetails">
Event Driven algorithm for Lagrangian systems</a></h3>
<b>Foreword:</b> <em> At the time, the only available event-driven algorithm in Siconos is for Lagrangian dynamical systems, subjected to perfect unilateral constraints and with the Newton impact rules. <br>
 A full description of such systems will be given in the Theoretical Manual and the results below are just a short and incomplete summary.</em> <br>
<p>
Because of the unilateral constraints, the evolution of the considered system may be non-smooth. Some jumps can occur in the velocity and the "acceleration" may not be defined everywhere. The generalized coordinates, assumed to be absolutely continuous are:<br>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ q(t) = q(t_0) +\int_{t_0}^t v^+(t)dt \ with \ v = \dot q \]" src="form_409.png">
<p>
 We will index with "+" and "-" right and left values of the variable at discontinuity. <br>
<p>
The equations of motion are written in terms of a measure differential equation: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ M(q)dv + F_{int}(t, q, v^+)dt=F_{ext}(t) + dr \]" src="form_405.png">
<p>
 r being the generalized force due the unilateral constraints. Using the Lebesgue decomposition theorem and its variants, the differential measure dv and dr are decomposed in: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} dv = \gamma dt + (v^+-v^-)\sum_i\delta_{t_i} + dv_s \\ dr = fdt + \sum_ip_i\delta_{t_i}+dr_s \end{eqnarray*}" src="form_410.png">
<p>
 First term of the decomposition corresponds to the smooth part, with <img class="formulaInl" alt="$ \gamma =\ddot q $" src="form_407.png">, the acceleration in the usual sense. The second term corresponds to the behavior at times of discontinuities, ( <img class="formulaInl" alt="$ \delta_{t_i} $" src="form_408.png">: Dirac), and the last term, a singular measure, will be neglected. <br>
<p>
Thanks to these decompositions, the non-smooth Dynamics can be split into "impact equations", that will correspond to the non-smooth events, and some "smooth Dynamics". These equations are completed by the constraints, formulated at different kinematics levels, as shown in the following paragraphs.<h3><a class="anchor" name="docSimuEDImpact">
The impact equations.</a></h3>
The impact equations can be written at the time, <img class="formulaInl" alt="$ t_i $" src="form_388.png"> of discontinuities: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ M(q(t_i))(v^{+}(t_i)- v^{-}(t_i)) = p_i, \]" src="form_380.png">
<p>
 <img class="formulaInl" alt="$ p_i $" src="form_381.png"> is like an impulsion. <br>
 This equation will be solved at the time of impact together with an impact law. That is for a Newton impact law <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M(q(t_i))(v^{+}(t_i)- v^{-}(t_i)) = p_i, \\ \dot y^{+}(t_i) = \nabla_q h(q(t_i)) v^{+}(t_i) \\ \dot y^{-}(t_i) = \nabla_q h(q(t_i)) v^{-}(t_i) \\ p_i = \nabla_q^T h(q(t_i)) P_{N,i}\\ 0\leq \dot y^{+}(t_i)+ e \dot y^{-}(t_i) \perp P_{N,i} \geq 0 \end{eqnarray*}" src="form_402.png">
<p>
 This problem can be reduced on the local unknowns <img class="formulaInl" alt="$ \dot y^{+}(t_i),P_{N,i} $" src="form_399.png"> if the matrix <img class="formulaInl" alt="$ M(q(t_i)) $" src="form_403.png"> is assumed to be invertible, leading to the following Linear Complementarity Problem at time <img class="formulaInl" alt="$ t_i $" src="form_388.png"> of discontinuities of v: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \dot y^{+}(t_i) = \nabla_q h(q(t_i)) (M(q(t_i)))^{-1} \nabla_q^T h(q(t_i)) P_{N,i} + \dot y^{-}(t_i) \\ 0\leq \dot y^{+}(t_i)+ e \dot y^{-}(t_i) \perp P_{N,i} \geq 0 \end{eqnarray*}" src="form_404.png">
<p>
 Later this system will be identified as <b>"LCP at velocity level"</b>.<h3><a class="anchor" name="docSimuEDSmoothDynt">
The smooth Dynamics.</a></h3>
The smooth dynamics which is valid almost everywhere for the Lebesgue measure <img class="formulaInl" alt="$ dt $" src="form_390.png"> is governed by the following equation: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M(q) \ddot q^+ + F_{int}(t, q, v^+)&amp;=&amp; F_{ext}(t) + f^+ \quad (dt-a.e.) \end{eqnarray*}" src="form_396.png">
<p>
 where we assume that <img class="formulaInl" alt="$ f^+=f^-=f\, (dt-a.e.) $" src="form_392.png">.<p>
The following smooth systems are then to be solved: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M(q(t)) \ddot q^{+}(t) + F_{int}(t, q, v^+)= F_{ext}(t) + f^{+}(t)\\ y = h(q(t)) \\ f^+ = \nabla_q h(q(t))^T F^+(t) \\ 0 \leq y \perp F^+(t) \geq 0 \end{eqnarray*}" src="form_397.png">
<p>
<p>
To solve these systems, at each time, i.e. to known the configuration after each events and to integrate it numerically, it is useful to express the complementarity laws at different kinematics level. We also introduce the pre-defined index sets (about index sets, see <a class="el" href="docSimu.html#docSimuIndexSets">Index Sets definition</a>):<br>
<p>
<img class="formulaInl" alt="$ I_0 $" src="form_337.png"> is the set of all the potential UnitaryRelations (UR). <br>
<p>
<img class="formulaInl" alt="$ I_1 = \{ ur_\alpha\in I_{0} , y_{\alpha} = 0 \} $" src="form_411.png"> (or if the UR is in <img class="formulaInl" alt="$ I_1 $" src="form_353.png"> then contact occurs). <br>
<p>
<img class="formulaInl" alt="$ I_2 = \{ ur_\alpha\in I_{1} , \dot y_{\alpha} = 0 \} $" src="form_412.png"> (or if the UR is in <img class="formulaInl" alt="$ I_2 $" src="form_355.png">, contact remains, no take off). <br>
<p>
This results in the new writing of the <b>"Bilateral Smooth Dynamics</b>:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M(q) \ddot q^{+} + F_{int}(t, q, v)= F_{ext} + \nabla_q h(q)^T F^+\\ \\ \ddot y^+ = \nabla_q h(q) \ddot q^+ + \dot{ \nabla_q h(q)} v^+ \\ \\ F^{+,\alpha} = 0, \quad \forall \alpha \in I_0-I_2 \\ \\ \ddot y^{+,\alpha} = 0 \quad \forall \alpha \in I_2 \end{eqnarray*}" src="form_419.png">
<p>
<p>
which can be reduced on variable <img class="formulaInl" alt="$ \ddot y^+ $" src="form_418.png"> and <img class="formulaInl" alt="$ F^+ $" src="form_416.png">, if M(q) is invertible, when <img class="formulaInl" alt="$ \alpha \in I_2 $" src="form_420.png">: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \ddot y^{+,\alpha} = \nabla_q h(q) M^{-1}(q)(- F_{int}(t, q, v^+)+ F_{ext}(t) ) + \dot{ \nabla_q h(q)} v^+ +\nabla_q h(q) M^{-1} \nabla_q h(q(t))^T F^{+,\alpha}(t) \\ \\ 0 \leq \ddot y^{+,\alpha} \perp F^{+,\alpha} \geq 0 \end{eqnarray*}" src="form_421.png">
<p>
 Later this system will be identified as <b>"LCP at acceleration level"</b>.<h3><a class="anchor" name="docSimuEDalgo">
The algorithm</a></h3>
Finally, the event-driven algorithm will be:<p>
knowing the value of <img class="formulaInl" alt="$ y, \dot y $" src="form_422.png"> and <img class="formulaInl" alt="$ I_1, I_2 $" src="form_423.png"> at the beginning of the time step <img class="formulaInl" alt="$ [t_k, t_{k+1}] $" src="form_424.png">:<p>
<ol type=1>
<li><b> Integration of the Bilateral Smooth Dynamics </b> up to an event given by the root-finding of the following function : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y^\alpha =0,\quad \forall \alpha \in I_0 - I_2 \\ or \\ F^{+,\alpha} = 0, \quad \forall \alpha \in I_2 \end{eqnarray*}" src="form_432.png">
<p>
 This results in the computation of <img class="formulaInl" alt="$ y, \dot y $" src="form_422.png"> at this new point and to an update of the index sets <img class="formulaInl" alt="$ I_1 $" src="form_353.png"> and <img class="formulaInl" alt="$ I_2 $" src="form_355.png">.</li><li>if <img class="formulaInl" alt="$ I_1 - I_2 \neq \emptyset $" src="form_426.png"> then Impacts occur:<ul>
<li>Formalize and solve the <b>"LCP at velocity level"</b></li><li>Update the index sets <img class="formulaInl" alt="$ I_1 $" src="form_353.png"> and <img class="formulaInl" alt="$ I_2 $" src="form_355.png"> and check that <img class="formulaInl" alt="$ I_1 - I_2 =\emptyset $" src="form_427.png"> <br>
 endif</li></ul>
</li><li>if <img class="formulaInl" alt="$ I_2\neq \emptyset $" src="form_428.png"> then<ul>
<li>Formalize and solve the <b>"LCP at acceleration level"</b></li><li>for <img class="formulaInl" alt="$ \alpha \in I_2 $" src="form_420.png"> do <br>
 if <img class="formulaInl" alt="$ \ddot y_{\alpha} >0, F_{\alpha} = 0 $" src="form_429.png"> remove <img class="formulaInl" alt="$ \alpha $" src="form_430.png"> from <img class="formulaInl" alt="$ I_2 $" src="form_355.png"> and <img class="formulaInl" alt="$ I_1 $" src="form_353.png"> <br>
 else if <img class="formulaInl" alt="$ \ddot y_{\alpha} =0, F_{\alpha}=0 $" src="form_431.png"> then undetermined case. endif<br>
 endfor<br>
 endif<br>
</li></ul>
</li><li>go to the next time step.</li></ol>
<h3><a class="anchor" name="docSimuEDLinkSico">
Implementation in Siconos</a></h3>
According to <a class="el" href="dsInSiconos.html#doc_lagds">Second order non linear Lagrangian dynamical systems</a>, in Siconos, the Dynamics of Lagrangian systems is written as: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M(q) \ddot q + NNL(\dot q, q) + F_{Int}(\dot q , q , t) &amp;=&amp; F_{Ext}(t) + p \\ \end{eqnarray*}" src="form_371.png">
<p>
 Next,<img class="formulaInl" alt="$ NNL $" src="form_372.png"> term will be forget and considered as included in <img class="formulaInl" alt="$ F_{Int} $" src="form_373.png">. <br>
 And Lagrangian relations are (see <a class="el" href="doc_Interactions.html#docRelationLag">Lagrangian Relation</a>): <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y &amp;=&amp; h(Q) \\ \dot y &amp;=&amp; \nabla_q h(Q)\dot Q \\ P &amp;=&amp; \nabla_q h(Q)^t\lambda \end{eqnarray*}" src="form_433.png">
<p>
 Q (resp. P) being a collection of all the q (resp. p) of the Dynamical Systems involved in the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/d0c/classInteraction.html">Interaction</a>. <br>
<p>
As we have seen in the previous section, the notion of kinematics level is really important. We introduce this in Siconos thanks to "[i]" notation. More precisely, for each Unitary <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/d1c/classRelation.html">Relation</a>, we define y[i] as the derivative number i of variable y, according to time. In the same way, we denote <img class="formulaInl" alt="$ \lambda[i] $" src="form_103.png"> the variable that is linked with y[i] through a Non-Smooth law (usually a complementarity). Finally to each <img class="formulaInl" alt="$ \lambda[i] $" src="form_103.png"> corresponds a p[i]. <br>
 To make things clearer, let us rewrite the previous defined systems with Siconos notations:<p>
<ul>
<li><b>"Bilateral Smooth Dynamics</b>: <br>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M(q) \ddot q + F_{int}(t, q, \dot q)= F_{ext} + \nabla_q h(q)^T \lambda[2] \\ \\ y[2] = \nabla_q h(q) \ddot q + \dot{ \nabla_q h(q)} \dot q \\ \\ \lambda[2]_{\alpha} = 0, \quad \forall \alpha \in I_0-I_2 \\ \\ y[2]_{\alpha} = 0 \quad \forall \alpha \in I_2 \end{eqnarray*}" src="form_438.png">
<p>
 with roots finding of: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} g(x,t) = y[0]_\alpha,\quad \forall \alpha \in I_0 - I_2 \\ or \\ g(x,t) = \lambda[2]_\alpha, \quad \forall \alpha \in I_2 \end{eqnarray*}" src="form_435.png">
<p>
</li></ul>
<p>
<ul>
<li><b>"LCP at velocity level"</b> <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y[1]^{+} = \nabla_q h(q(t_i)) (M(q(t_i)))^{-1} \nabla_q^T h(q(t_i))\lambda[1] + y[1]^{-} \\ 0\leq y[1]^{+} + e y[1]^{-} \perp \lambda[1] \geq 0 \end{eqnarray*}" src="form_439.png">
<p>
</li></ul>
<p>
<ul>
<li><b>"LCP at acceleration level"</b> <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y[2]_{\alpha} = \nabla_q h(q) M^{-1}(q)(- F_{int}(t, q, \dot q)+ F_{ext}(t) ) + \dot{ \nabla_q h(q)} \dot q +\nabla_q h(q) M^{-1} \nabla_q h(q(t))^T \lambda[2]_{\alpha} \\ \\ 0 \leq y[2]_{\alpha}\perp \lambda[2]_{\alpha} \geq 0 \end{eqnarray*}" src="form_441.png">
<p>
</li></ul>
<p>
Then, to build an <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a> simulation, it is necessary to define two OneStepNSProblems, one at velocity and one at acceleration level. So here is a classical code for simulation construction: <div class="fragment"><pre class="fragment"><a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a>* s = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html">EventDriven</a>(ball);
<span class="comment">// -- Time discretisation --</span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html">TimeDiscretisation</a> * t = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html">TimeDiscretisation</a>(timeStep,s);
<span class="comment">// -- OneStepIntegrators --</span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d8/d72/classOneStepIntegrator.html">OneStepIntegrator</a> * OSI = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/dbb/classLsodar.html">Lsodar</a>(setOfDS,s); 
<span class="comment">// -- OneStepNsProblem --</span>
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/df/db1/classOneStepNSProblem.html">OneStepNSProblem</a> * impact = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a>(s, <span class="stringliteral">"impact"</span>,solverName,101, 0.0001,<span class="stringliteral">"max"</span>,0.6);
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/df/db1/classOneStepNSProblem.html">OneStepNSProblem</a> * acceleration = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a>(s, <span class="stringliteral">"acceleration"</span>,solverName,101, 0.0001,<span class="stringliteral">"max"</span>,0.6);
</pre></div><p>
Finally, the algorithm described earlier is:<p>
<ol type=1>
<li>Integration of the Bilateral Smooth Dynamics: <br>
 To integrate these systems thanks to lsodar, we need to define f(x,t) and g(x,t). <br>
 To compute f(x,t), we:<ul>
<li>formalize and solve a "LCP at acceleration level" to compute <img class="formulaInl" alt="$ (y[2],lambda[2]) $" src="form_442.png"></li><li>collect and rewrite the Dynamics of all the Dynamical Systems as a first order system, including the result of the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a> computation. The function g(x,t) is given by: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} g(x,t) &amp;=&amp; y[0], \quad \forall \alpha \in I_0 - I_2 \\ \\ g(x,t) &amp;=&amp; \lambda[2], \quad \forall \alpha \in I_2 \end{eqnarray*}" src="form_368.png">
<p>
 Corresponding code: <div class="fragment"><pre class="fragment">s-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d2/dac/classEventDriven.html#9af302469af533f599fc4ddcd5cad79c">advanceToEvent</a>()
<span class="comment">// This results in a call to Lsodar-&gt;integrate and to schedule of new non-smooth events if necessary</span>
</pre></div> The next steps are done during call to eventsManager-&gt;processEvents(), but they will be detailed below.</li></ul>
</li><li>Compute y[0] and y[1] and update the index sets <div class="fragment"><pre class="fragment">simulation-&gt;updateOutput(0, 1);
simulation-&gt;updateIndexSets();
</pre></div></li><li>if <img class="formulaInl" alt="$ I_1 - I_2 \neq \emptyset $" src="form_426.png">, formalize and solve a <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a> at velocity level: <div class="fragment"><pre class="fragment">simulation-&gt;computeOneStepNSProblem(<span class="stringliteral">"impact"</span>); 
</pre></div></li><li>compute p[1], post-impact velocity, y[1] and indexSet[2] simulation-&gt;update(1);</li><li>if <img class="formulaInl" alt="$ I_2 \neq \emptyset $" src="form_443.png">, formalize and solve a <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a> at acceleration level, and update index sets with some conditions <div class="fragment"><pre class="fragment">simulation-&gt;computeOneStepNSProblem(<span class="stringliteral">"acceleration"</span>);
simulation-&gt;updateIndexSetsWithDoubleCondition();
</pre></div></li><li>next time step <div class="fragment"><pre class="fragment">simulation-&gt;nextStep();
</pre></div> </li></ol>

<h2><a class="anchor" name="docSimuMoreauTS">Moreau's Time Stepping scheme</a></h2><b> Foreword: </b> <em> At the time, Moreau's Time Stepping scheme is only implemented for first order linear systems and for Lagrangian systems. </em><h3><a class="anchor" name="docSimuTSPrinciple">
General Principle</a></h3>
Roughtly speaking, this algorithm consists first in the discretisation of the whole system (dynamics + relations + non-smooth laws) over a time step. Then the system is integrated and that leads to the computation of some "free" solutions, ie without any constraints. Finally a Non-Smooth problem (usually a <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a>) is formalized and solved to obtain the complete solution.<h3><a class="anchor" name="docSimuTSimplem">
Implementation</a></h3>
<b>Related</b> <b>classes:</b> <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html">TimeStepping</a>, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/db/de1/classMoreau.html">Moreau</a>, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a>, <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dd/da1/classFrictionContact.html">FrictionContact</a><p>
The figure below represents the class architecture for <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html">TimeStepping</a> simulation.<p>
<div align="center">
<img src="classTimeStepping.png" alt="classTimeStepping.png">
</div>
<p>
We will now describe discretisation process for two differents cases: first order linear systems and then Lagrangian systems, linear and time invariant.<h3><a class="anchor" name="docSimuTSDiscretisationLDS">
First order linear systems</a></h3>
This section concerns <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d6f/classLinearTIDS.html">LinearTIDS</a> DynamicalSystems (see <a class="el" href="dsInSiconos.html">Dynamical Systems formulations in Siconos</a>) <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \dot x &amp;=&amp; Ax + Tu + b + r \\ x(t_0) &amp;=&amp; x_0 \end{eqnarray*}" src="form_250.png">
<p>
 with linear relations (<a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d6/db1/classLinearTIR.html">LinearTIR</a>): <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y &amp;=&amp; CX + FU + D \lambda + e \\ R &amp;=&amp; B \lambda \end{eqnarray*}" src="form_125.png">
<p>
<h4><a class="anchor" name="docMoreauLDSTD">
Time Discretisation of the Dynamics</a></h4>
The integration of the ODE over a time step <img class="formulaInl" alt="$ [t_i,t_{i+1}]$" src="form_223.png"> of length <img class="formulaInl" alt="$ h$" src="form_224.png"> is :<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{t_i}^{t_{i+1}}\dot x\,dt = \int_{t_i}^{t_{i+1}} A \cdot x\,dt + \int_{t_i}^{t_{i+1}}(T \cdot u + b) dt + \int_{t_i}^{t_{i+1}}r\,dt \]" src="form_253.png">
<p>
 The left-hand term is <img class="formulaInl" alt="$ x(t_{i+1})-x(t_i)$" src="form_226.png"> . <br>
 Right-hand terms are approximated this way :<p>
<img class="formulaInl" alt="$ \int_{t_i}^{t_{i+1}} A \cdot x\,dt$" src="form_227.png"> is approximated using a <img class="formulaInl" alt="$ \theta$" src="form_228.png"> -method <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{t_i}^{t_{i+1}} A \cdot x\,dt \approx h \theta (A \cdot x(t_{i+1})) + h (1-\theta) (A \cdot x(t_{i})) \]" src="form_229.png">
<p>
<p>
since the second integral comes from independent sources, it can be evaluated with whatever quadrature method, for instance a <img class="formulaInl" alt="$ \theta$" src="form_228.png"> -method <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{t_i}^{t_{i+1}}(T \cdot u + b) dt \approx h \theta (T \cdot u(t_{i+1}) + b(t_{i+1})) + h (1-\theta) (E \cdot u(t_{i}) + b(t_{i})) \]" src="form_254.png">
<p>
<p>
the third integral is approximated like in an implicit Euler integration <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{t_i}^{t_{i+1}}r\,dt \approx h r(t_{i+1}) \]" src="form_231.png">
<p>
<p>
By replacing the accurate solution <img class="formulaInl" alt="$ x(t_i)$" src="form_232.png"> by the approximated value <img class="formulaInl" alt="$ x_i$" src="form_233.png"> , we get : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{i+1}-x_i = h \theta (A \cdot x_{i+1}) + h (1-\theta) (A \cdot x_{i}) + h \theta (T \cdot u(t_{i+1}) + b(t_{i+1})) + h (1-\theta) (T \cdot u(t_{i}) + b(t_{i})) + h r_{i+1} \]" src="form_255.png">
<p>
 Assuming that <img class="formulaInl" alt="$ I - h \theta A$" src="form_235.png"> is invertible, matrix <img class="formulaInl" alt="$ W$" src="form_236.png"> is defined as <img class="formulaInl" alt="$ (I - h \theta A)^{-1}$" src="form_237.png"> . We get then : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{i+1} = W(I + h (1-\theta) A) \cdot x_{i} + W (h \theta (T \cdot u(t_{i+1}) + b(t_{i+1})) + h (1-\theta) (T \cdot u(t_{i}) + b(t_{i}))) + h W r_{i+1} \]" src="form_256.png">
<p>
 An intermediate variable <img class="formulaInl" alt="$ x_{free}$" src="form_239.png"> related to the smooth part of the system is defined as : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{free} = W(I + h (1-\theta) A) \cdot x_{i} + W (h \theta (T \cdot u(t_{i+1}) + b(t_{i+1})) + h (1-\theta) (T \cdot u(t_{i}) + b(t_{i}))) \]" src="form_257.png">
<p>
 Thus the calculus of <img class="formulaInl" alt="$ x_{i+1}$" src="form_241.png"> becomes : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{i+1} = x_{free} + h W r_{i+1} \]" src="form_242.png">
<p>
<h4><a class="anchor" name="docMorTDLDSRel">
Time discretization of the relations</a></h4>
It comes straightforwardly :<br>
<p>
<img class="formulaInl" alt="$ r_{i+1} = B \cdot \lambda_{i+1}$" src="form_258.png"> <br>
<p>
<img class="formulaInl" alt="$ y_{i+1} = C \cdot x_{i+1} + D \cdot \lambda_{i+1} + F \cdot u(t_{i+1}) + e $" src="form_244.png"><br>
<h4><a class="anchor" name="docMorTDLDSNSL">
Time discretization of the non-smooth law</a></h4>
It comes straightforwardly : <p class="formulaDsp">
<img class="formulaDsp" alt="\[ 0 \leq y_{i+1} \, \perp \, \lambda_{i+1} \geq 0 \]" src="form_245.png">
<p>
<h4><a class="anchor" name="docMoreauTDLDSSumup">
Summary of the time discretized equations</a></h4>
These equations are summarized assuming that there is no source term and simplified relations as for the electrical oscillator with full-wave rectifier.<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} W &amp; = &amp; (I - h \theta A)^{-1} \\ x_{free} &amp;= &amp; W(I + h (1-\theta) A) \cdot x_{i} \\ x_{i+1} &amp;= &amp; x_{free} + h W r_{i+1} \\ r_{i+1} &amp;= &amp; B \cdot \lambda_{i+1} \\ y_{i+1} &amp;= &amp; C \cdot x_{i+1} + D \cdot \lambda_{i+1}+ Fu_{i+1} \\ 0 \leq y_{i+1} \, &amp;\perp&amp; \, \lambda_{i+1} \geq 0 \end{eqnarray*}" src="form_444.png">
<p>
<h3><a class="anchor" name="docMoreauLag">
Lagrangian Linear Systems case</a></h3>
We consider now Lagrangian Linear and Time Invariant systems (<a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d8/de0/classLagrangianLinearTIDS.html">LagrangianLinearTIDS</a>, see <a class="el" href="dsInSiconos.html#doc_lagtids">Second order linear and time-invariant Lagrangian dynamical systems.</a>): <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M \ddot q + C \dot q + K q = F_{Ext}(t) + p \\ q(t_0) = q0 \\ \dot q(t_0) = velocity0 \end{eqnarray*}" src="form_252.png">
<p>
 with Lagrangian Linear Relations (<a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/dbe/classLagrangianR.html">LagrangianR</a>, see <a class="el" href="doc_Interactions.html#docRelationLagLin">Lagrangian Linear Relation</a>): <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y&amp;=&amp; H q + b + D\lambda \\ p&amp;=&amp; H^t \lambda \end{eqnarray*}" src="form_127.png">
<p>
<h4><a class="anchor" name="docMoreauTDDS">
Time discretization of the dynamical system</a></h4>
We provide in this section a time discretization method of the Lagrange dynmical system, consistent with the non smooth character of the solution. Let us consider here only the linear time invariant case. The equation may be reformulated equivalently in terms of an integral over a time step <img class="formulaInl" alt="$ [t_i,t_{i+1}] $" src="form_181.png"> of length h such that : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \int_{[t_i,t_{i+1}]} M \ddot q + C \dot q + K q \,dt = \int_{[t_i,t_{i+1}]} F_{ext}(t)\,dt + \int_{[t_i,t_{i+1}]} r \,d\nu \end{eqnarray*}" src="form_206.png">
<p>
<p>
Due to the non smooth character of the motion, the first term is integrated by an one order scheme( backward Euler-like) such that : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \int_{[t_i,t_{i+1}]} M \ddot q \, dt \approx M (\dot q(t_{i+1})-\dot q(t_{i})) \end{eqnarray*}" src="form_207.png">
<p>
<p>
For simplicity sake, we note the approximation of q and <img class="formulaInl" alt="$ \dot q $" src="form_184.png">: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \dot q_{i+1}\approx\dot q(t_{i+1}), \dot q_{i}\approx \dot q(t_{i}) \end{eqnarray*}" src="form_208.png">
<p>
<p>
For the other terms, a <img class="formulaInl" alt="$ \theta $" src="form_162.png">-method is used : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \int_{[t_i,t_{i+1}]} C \dot q + K q \,dt &amp;\approx&amp; h\left[\theta (C \dot q_{i+1}+K q_{i+1}) + (1-\theta) (C \dot q_{i}+K q_{i}) \right]\\ \int_{[t_i,t_{i+1}]} F_{ext}(t) \,dt &amp;\approx&amp; h\left[\theta F_{ext}(t_{i+1})+(1-\theta) F_{ext}(t_{i}) \right] \end{eqnarray*}" src="form_209.png">
<p>
<p>
For the term which contains the reaction force, we state a new variable such that : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} R_{i+1} = \frac 1 h \int_{[t_i,t_{i+1}]} r \,d\nu \end{eqnarray*}" src="form_210.png">
<p>
<p>
The displacement is integrated through the velocity with : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} q_{i+1} = q_{i} + h\left[\theta \dot q_{i+1}+(1-\theta) \dot q_{i} \right]\\ \end{eqnarray*}" src="form_211.png">
<p>
<p>
Finally, we obtain the time discretized equation of motion: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left[M+h\theta C + h^2 \theta^2 K\right] (\dot q_{i+1} - \dot q_{i}) = - h C \dot q_{i} - h K q_{i} - h^2 \theta K \dot q_{i} + h\left[\theta F_{ext}(t_{i+1})+(1-\theta) F_{ext}(t_{i}) \right] +h R_{i+1}, \end{eqnarray*}" src="form_212.png">
<p>
 which can be written : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \dot q_{i+1} = \dot q_{free} + h W R_{i+1} \end{eqnarray*}" src="form_213.png">
<p>
 where <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} W &amp;=&amp; \left[M+h\theta C + h^2 \theta^2 K\right]^{-1}\\ \dot q_{free} &amp;=&amp; \dot q_{i}+ W \left[ - h C \dot q_{i} - h K q_{i} - h^2 \theta K \dot q_{i} + h\left[\theta F_{ext}(t_{i+1})+(1-\theta) F_{ext}(t_{i}) \right] \right] \end{eqnarray*}" src="form_214.png">
<p>
<p>
The free velocity <img class="formulaInl" alt="$ \dot q_{free} $" src="form_192.png"> correponds to the velocity of the system without any constraints.<h4><a class="anchor" name="docMoreauTDRel">
Time discretization of the relations</a></h4>
The Time discretization of the relations is fully implicit and may be written as : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y_{i+1} &amp;=&amp; H^{T} q_{i+1} + b\\ \dot y_{i+1} &amp;=&amp; H^{T}\dot q_{i+1} \\ R_{i+1} &amp;=&amp; H \lambda_{i+1} \end{eqnarray*}" src="form_215.png">
<p>
<h4><a class="anchor" name="docMoreauTDNSlaw">
Time discretization of the Non Smooth laws</a></h4>
A natural way of discretizing the unilateral constraint leads to the following implicit discretization : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} 0 \leq y_{i+1} \perp \lambda_{i+1} \geq 0 \end{eqnarray*}" src="form_216.png">
<p>
<p>
In the Moreau's time--stepping, we use a reformulation of the unilateral constraints in terms of velocity: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} If y(t) =0, \ then \ 0 \leq \dot y \perp \lambda \geq 0 \end{eqnarray*}" src="form_217.png">
<p>
 which leads to the following discretisation : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} If \ y^{p} \leq 0, \ then \ 0 \leq \dot y_{i+1} \perp \lambda_{i+1} \geq 0 \end{eqnarray*}" src="form_218.png">
<p>
 where <img class="formulaInl" alt="$ y^{p} $" src="form_197.png"> is a prediction of the position at time <img class="formulaInl" alt="$ t_{i+1} $" src="form_198.png">, for instance, <img class="formulaInl" alt="$ y^{p} = y_{i} + \frac{h}{2} \dot y_i $" src="form_199.png">.<p>
If we want to introduce now the Newton impact law, we consider an equivalent velocity defined by <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \dot y^{e}_{i+1} = \dot y_{i+1} + e \dot y_{i} \end{eqnarray*}" src="form_219.png">
<p>
 and we apply the constraints directly on this velocity : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} If \ y^{p} \leq 0, \ then \ 0 \leq \dot y^{e}_{i+1} \perp \lambda_{i+1} \geq 0 \end{eqnarray*}" src="form_220.png">
<p>
<h4><a class="anchor" name="docMoreauTDSumup">
Summary of the time discretized equations</a></h4>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \dot q_{i+1} &amp;=&amp; \dot q_{free} + h W R_{i+1} \\ q_{i+1} &amp;=&amp; q_{i} + h\left[\theta \dot q_{i+1}+(1-\theta) \dot q_{i} \right] \\ \dot y_{i+1} &amp;=&amp; H^{T}\dot q_{i+1} \\ R_{i+1} &amp;=&amp; H \lambda_{i+1}\\ y^{p} &amp;=&amp; y_{i} + \frac{h}{2} \dot y_i\\ If &amp;y^{p}&amp; \leq 0, \ then \ 0 \leq \dot y^{e}_{i+1} \perp \lambda_{i+1} \geq 0 \end{eqnarray*}" src="form_221.png">
<p>
<p>
This set of equations can be reduced to a "condensed" system in terms of <img class="formulaInl" alt="$ \dot y^{e}_{i+1} $" src="form_203.png"> and <img class="formulaInl" alt="$ {\lambda_{i+1}} $" src="form_204.png"> : <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \dot y^{e}_{i+1} &amp;=&amp; H^{T} \dot q_{free} + h H^{T} W H \lambda_{i+1} + e \dot y_{i}\\ y^{p} &amp;=&amp; y_{i} + \frac{h}{2} \dot y_i\\ If &amp;y^{p}&amp; \leq 0, \ then \ 0 \leq \dot y^{e}_{i+1} \perp \lambda_{i+1} \geq 0 \end{eqnarray*}" src="form_222.png">
<p>
<h3><a class="anchor" name="docSimuTSProcess">
The Simulation process</a></h3>
As for Event-Driven, we introduce level index sets, with level = 0 for first order systems and level=1 for second order systems (this is related to the relative degrees but we won't get into details about that here). <br>
<p>
<img class="formulaInl" alt="$ I_0 $" src="form_337.png"> is the set of all the potential UnitaryRelations (UR). <br>
 For second order systems: <br>
 <img class="formulaInl" alt="$ I_1 = \{ ur_\alpha\in I_{0} , y^p_{\alpha} = 0 \} $" src="form_445.png">. <br>
 Thus, the <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a> is built only for unitary relations that belongs to <img class="formulaInl" alt="$ I_level $" src="form_446.png">, level=0 for first order and level=1 for second order systems.<p>
Then, the steps of a Moreau's Time-Stepping simulation will be:<p>
Knowing all values at the beginning of the time step <img class="formulaInl" alt="$ [t_i,t_{i+1}] $" src="form_181.png">,<p>
<ol type=1>
<li>compute the free solutions</li><li>for <img class="formulaInl" alt="$ ur \in I_level $" src="form_448.png"> formalize and solve a <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a></li><li>update the state (according to the possibly <a class="elRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d3/d48/classLCP.html">LCP</a> results)</li><li>go to next time step</li></ol>
<p>
<div class="fragment"><pre class="fragment"><a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html">TimeStepping</a> * s = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html">TimeStepping</a>(myModel);
<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html">TimeDiscretisation</a> * t = <span class="keyword">new</span> <a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html">TimeDiscretisation</a>(timeStep,s);

s-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html#bd3d2179e957313d0fa9efc5248a47c0">initialize</a>();

<span class="keywordtype">int</span> k = t-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html#00bdac9ac3339ba4fd506d090b16800e">getK</a>(); <span class="comment">// Current step </span>
<span class="keywordtype">int</span> N = t-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html#a6008d0dad03031590d9bb7ceb469eff">getNSteps</a>(); <span class="comment">// Number of time steps</span>

<span class="comment">// --- Time loop ---</span>
<span class="keywordflow">while</span>(k &lt; N)<span class="comment">// for each time step ...</span>
{
<span class="comment">// transfer of state i+1 into state i and time incrementation</span>
s-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html#ef27267d7714e35607e18a7dfb3119bf">nextStep</a>();
<span class="comment">// get current time step</span>
k = t-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/dc/d1e/classTimeDiscretisation.html#00bdac9ac3339ba4fd506d090b16800e">getK</a>();
<span class="comment">// compute xFree, or qFree,vFree</span>
s-&gt;computeFreeStep();
<span class="comment">// Update the index sets (ie compute prediction yp for Lagrangian Systems)</span>
s-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d1/d7b/classSimulation.html#12482d2abb194cbe5b084abb8f2174ce">updateIndexSets</a>();
<span class="comment">// Formalize and solve a LCP</span>
computeOneStepNSProblem(<span class="stringliteral">"timeStepping"</span>);
<span class="comment">// Update state, using last computed values</span>
s-&gt;<a class="codeRef" doxygen="DoxygenKernel.tag:http://siconos.gforge.inria.fr/Doxygen/" href="http://siconos.gforge.inria.fr/Doxygen/d7/dc9/classTimeStepping.html#0e489cc1604e049d544b003d5e88536c">update</a>(level); <span class="comment">// </span>
}
</pre></div><p>
Note that all time-independent operators are computed during simulation initialisation. 

</div>
</div>
</div>
</body>
</html>
