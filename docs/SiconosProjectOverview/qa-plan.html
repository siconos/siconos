<?xml version="1.0" encoding=""?>
<!DOCTYPE html PUBLIC "-//Tigris//DTD XHTML 1.0 Transitional//EN"
       "http://style.tigris.org/tigris_transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="" />
  <title>QA Plan</title>
  <style type="text/css">
/* <![CDATA[ */ 
@import "css/readyset.css"; 
@import "css/inst.css";
/*   */
 ]]>


  </style>
  <link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
</head>

<body>

<div class="app">

<div class="readyset">
<h1>Quality Assurance Plan</h1>

<div id="releaseinfo">
<h2>Release Information</h2>

<table class="axial" border="1" cellpadding="3" cellspacing="2">
  <tbody>
    <tr>
      <th>Project</th>
      <td><a href="index.html">Siconos</a></td>
    </tr>
    <tr>
      <th>Internal Release Number:</th>
      <td>1.0<br />
      </td>
    </tr>
    <tr>
      <th>Last update:</th>
      <td>September 15, 2005</td>
    </tr>
    <tr>
      <th>Attached Worksheets:</th>
      <td>
        <div>
        QA plan &gt; Quality Report<br />
        </div>
      </td>
    </tr>
    <tr>
      <th>Related Documents:</th>
      <td>
        <div>
        <a href="srs.html">Software Requirements Specification</a></div>

        <div>
        <a href="design.html">Design</a></div>

        <div>
        <a href="sdm.html">Software development methodology</a></div>

        <div>
        <a href="glossary.html#ESA">ESA</a> software engineering standards<br
        />
        </div>
      </td>
    </tr>
  </tbody>
</table>
</div>
<!-- /releaseinfo -->

<div id="processimpact">
<strong>Process impact:</strong> This document specifies quality goals,
selects strategies for assuring that those goals have been met, and details a
plan of action to carry out those strategies.</div>
<!-- /processimpact -->

<div id="introduction">
<h2>Introduction</h2>
<br />
The purpose of the quality assurance plan is to check that the project is
consistent with standards and plans which are defined below. As it is
recommended by the <a href="glossary.html#ESA">ESA</a> software engineering
standards to small software projects, the Quality Plan combines the following
documents for small projects :
<ul>
  <li>The software Project Management Plan.</li>
  <li>The software Configuration Management Plan.</li>
  <li>The software Verification and Validation Plan.</li>
</ul>
References<br />

<ul>
  <li>"Guide to applying the <a href="glossary.html#ESA">ESA</a> software
    engineering standards to small software projects. ", BSSC(96)2, <a
    href="glossary.html#ESA">ESA</a> 1996,</li>
  <li>"Guide to the software project management ", PSS-05-08, <a
    href="glossary.html#ESA">ESA</a> 1995,</li>
  <li>"Guide to the software configuration management", PSS-05-09, <a
    href="glossary.html#ESA">ESA</a> 1995,</li>
  <li>"Guide to the software verification and validation", PSS-05-10, <a
    href="glossary.html#ESA">ESA</a> 1995,</li>
  <li>"Guide to the software quality assurance", PSS-05-11, <a
    href="glossary.html#ESA">ESA</a> 1995,</li>
</ul>
<br />


<h2>Project Management Plan</h2>

<h3>Introduction</h3>
Software project management is 'the process of planning, organizing,
staffing, monitoring, controlling and leading a software project'. This part
is based on the <a href="glossary.html#ESA">ESA</a> ``guide to the software
project management'', PSS-05-08, <a href="glossary.html#ESA">ESA</a> 1995.<br
/>
<br />
This part defines the project management plan of the siconos platform. The
project organization and the major features of the technical process are
defined. Finally, a work breakdown structure, a schedule with milestones and
the roles and responsibilities are provided.

<p>Actually, only the project management plan, and the technical process for
<a href="glossary.html#Siconos/Kernel">Siconos/Kernel</a> and <a
href="glossary.html#Siconos/Numerics">Siconos/Numerics</a> are detailed.</p>

<p>For the more elaborate part of the platform, which are <a
href="glossary.html#Siconos/Analysis">Siconos/Analysis</a>, Siconos/Control
and Siconos/IMSE, separated documents will be provided. <br />
</p>

<h3><a name="Project_Organisation"></a>Project Organization<br />
</h3>

<h4>Organizational roles and responsibilities<br />
</h4>
<br />


<p>Due to the number of participants in the software project development, the
organization of the project is relatively simple. The Work Package 2
(Numerical Methods and Software development) is led by Vincent ACARY (C01),
which is also the project manager of the software design and development. <br
/>
</p>

<p>The teams for the design and the development are defined as follows :</p>
<ol>
  <li>Team INRIA (C01):
    <dl compact="compact">
    </dl>
    <ul>
      <li>Vincent Acary (VA) (Team Leader, designer, programmer)
        Vincent.Acary@inrialpes.fr</li>
      <li>Roger Pissard-Gibollet (RPG) (Software quality leader)</li>
      <li>Franck Pérignon (FP) (programmer, test engineer , numerical
        algorithms)</li>
    </ul>
    <dl compact="compact">
    </dl>
    Former members:</li>
</ol>
<ul>
  <ul>
    <li>Jean-Baptiste Charlety (JBC) (programmer, test engineer , software
      librarian) (01/2004 to 04/2005)</li>
    <li>Jean-Michel Barbier (JMB) (programmer, test engineer, software
      librarian) (01/2004 to 09/2004)</li>
  </ul>
</ul>
<ol start="2">
  <li>Team LMGC (AC2): <br />

    <dl compact="compact">
    </dl>
    <ul>
      <li>Frédéric Dubois (FD) (Team Leader, designer, programmer)</li>
      <li>Shéherazade Nineb (SN) (programmer)</li>
    </ul>
    Former members:</li>
</ol>
<ul>
  <ul>
    <li>Jean-Michel Barbier (JMB) (programmer, test engineer, software
      librarian)(10/2004 to 04/2005)</li>
  </ul>
</ul>
<ol start="3">
  <li>Team Analysis (CR6,CR4,CR9,AC5,CR7,AC12,CR8),</li>
</ol>
<ol start="4">
  <ol>
    <li>Key Developpers
      <ul>
        <li>Gustavo Osorio (GA) gosorio@unina.it</li>
        <li>Ivan Merillas (IM) merillas@mat.upc.edu</li>
        <li>Petri Piiroinen (PP) petri.piiroinen@bristol.ac.uk</li>
      </ul>
    </li>
    <li>Developpers
      <ul>
        <li>Fabiola angulo (FA) fangulo@nevado.manizales.unal.edu.co</li>
        <li>Alan Champneys (AR) a.r.champneys@bristol.ac.uk</li>
        <li>Enric Fossas (EF) enric.fossas@upc.edu <br />
        </li>
        <li>Gino Ianelli (GI) luigi.iannelli@unisannio.it</li>
        <li>Arne Nordmark (AN) nordmark@mech.kth.se</li>
        <li>Gerard Olivar (GO) gerard@mat.upc.edu</li>
      </ul>
    </li>
    <li>Testing team
      <ul>
        <li>Mario Di Bernardo (MdB) m.dibernardo@bristol.ac.uk</li>
        <li>Kanat Camlibel (KC) k.camlibel@uvt.nl</li>
        <li>Ugo Galvenetto (UG) u.galvanetto@imperial.ac.uk</li>
        <li>Stefania Santini (SS) stsantini@unina.it</li>
        <li>David Wagg (DW) david.wagg@bristol.ac.uk</li>
        <li>Nathan van der Vouw (NW) n.v.d.wouw@tue.nl</li>
      </ul>
    </li>
  </ol>
</ol>
<ol start="4">
  <li>Team "Control", <a href="glossary.html#TBD">TBD</a></li>
  <li>Team imse, <a href="glossary.html#TBD">TBD</a></li>
</ol>
<ul>
  <ul>
  </ul>
</ul>

<p>The roles and responsibilities are roughly distributed in the table <a
href="../QP/QP/QP.html#Tab:Role1">2.1</a>. <br />
</p>

<p><br />
</p>

<div align="center">
<a name="351"></a>

<table>
  <caption><strong>Table 2.1:</strong> Roles and responsibilities</caption>
  <tbody>
    <tr>
      <td>
        <div align="center">

        <table border="1" cellpadding="3">
          <tbody>
            <tr>
              <td align="left">Role</td>
              <td align="left">Teams</td>
            </tr>
            <tr>
              <td align="left"><a
                href="glossary.html#Siconos/Numerics">Siconos/Numerics</a></td>
              <td align="left">Team LMGC, Team INRIA</td>
            </tr>
            <tr>
              <td align="left"><a
                href="glossary.html#Siconos/Kernel">Siconos/Kernel</a></td>
              <td align="left">Team INRIA, Team LMGC</td>
            </tr>
            <tr>
              <td style="vertical-align: top;"><a
                href="glossary.html#Siconos/Front-End">Siconos/Front-End</a><br
                />
              </td>
              <td style="vertical-align: top;">Team INRIA<br />
              </td>
            </tr>
            <tr>
              <td align="left"><a
                href="glossary.html#Siconos/Analysis">Siconos/Analysis</a></td>
              <td align="left">Team Analysis</td>
            </tr>
            <tr>
              <td align="left">Siconos/Control</td>
              <td align="left">Team Control</td>
            </tr>
          </tbody>
        </table>
        <a name="Tab:Role1"></a></div>
      </td>
    </tr>
  </tbody>
</table>
</div>
<br />
<br />


<h4>Organisational interfaces.</h4>
<br />


<p>The initiators of the project are the members of the Work Package 2. The
end users of the platform are the whole community of SICONOS, at least, for
the first release. Then further distributions of the software will take into
account the requirements of a wider scientific community, and then, of the
industrial partners.</p>

<p>The interfaces between the Work Package 2 and the community of users is
under the responsibility of the project manager.</p>
<br />


<h3>Technical Process for the Siconos/Platform</h3>
<br />


<p>The section below focuses only on the technical process for the <a
href="glossary.html#Siconos/Numerics">Siconos/Numerics</a> and the <a
href="glossary.html#Siconos/Kernel">Siconos/Kernel</a> of the platform. It
should be extended for the analysis, control and the imse.</p>

<h4><a name="SECTION00331000000000000000">Process model</a></h4>

<h5><a name="SECTION00331100000000000000">Definitions of the phases of the
design and the development</a></h5>

<p>Following the <a href="glossary.html#ESA">ESA</a> standards for small
projects <a href="glossary.html#ESA">ESA</a>-PSS050, the following phases of
the design and the development are defined :</p>
<ul>
  <li><b>The UR/SR phase</b>. The UR phase is the ``problem definition
    phase'' of a software project. The scope of the system must be defined.
    The user requirements must be captured. The SR phase is the ``analysis''
    phase of a software project. A vital part of the analysis activity is the
    construction of a ``model'' describing <i>what</i> the software has to
    do, and not <i>how</i> to do it. Building prototypes to clarify the
    software requirements may be necessary. The principal deliverables of
    this phase are the User requirements Document (URD) and the Software
    Requirements document (SRD).</li>
  <li><b>The AD phase</b>.The purpose of the AD phase is to define the
    structure of the software. The model constructed in the SR phase is the
    starting point.This model is transformed into the architectural design by
    allocating functions to software components and defining the control and
    data flow between them. The deliverable item which constitutes the formal
    output of this phase is the Architectural Design Document (ADD).</li>
  <li><b>The DD Phase</b> The purpose of the DD phase is to detail the design
    of the software, and to code, document and test it. The Detailed Design
    Document (DDD) and the Software User Manual (SUM) are produced
    concurrently with coding and testing.</li>
  <li><b>The TR Phase</b> The purpose of this phase is to establish that the
    software fulfills the requirements laid down in the SRD. This is done by
    installing the software and conducting acceptance tests.</li>
  <li><b>The OM Phase</b> Once the software has entered into operation, it
    should be carefully monitored to confirm that it meets all the
    requirements defined in the SRD. Some of the requirements, for example
    those for availability, may take a period of time to validate. When the
    software has passed all the acceptance tests, it can be finally accepted.
    This is the OM Phase.</li>
</ul>

<h5><a name="SECTION00331200000000000000">Project planning inputs and
outputs</a></h5>

<p>The inputs to software project planning are:</p>
<ul>
  <li>User requirements</li>
  <li><a href="srs.html">Software requirements specification</a> and <a
    href="design.html">design</a> documents according to each phases<br />
  </li>
  <li><a href="glossary.html#ESA">ESA</a> software standards for products and
    procedures;</li>
  <li>time constraints, such as delivery dates;</li>
  <li>resource constraints, such as the availability of staff;</li>
</ul>

<p>The outputs to software project planning are:</p>
<ul>
  <li>code</li>
  <li><a href="srs.html">software specification</a> and <a
    href="design.html">design</a> documents</li>
  <li>Quality report <br />
  </li>
</ul>

<p>The Table <a href="file://qa-plan.html#Tab:IO-Products">2.2</a> summarizes
the software products of each phase as required by <a
href="glossary.html#ESA">ESA</a> PSS-05-0. The timetable for the output
deliverables will be given in the part schedule. <br />
</p>

<div align="center">
<a name="411"></a>

<table>
  <caption><strong>Table 2.2:</strong> Phase input and output
  products</caption>
  <tbody>
    <tr>
      <td>
        <div align="center">

        <table style="width: 651px; height: 246px;" border="1"
        cellpadding="3">
          <tbody>
            <tr>
              <td align="left" valign="top" width="181">Phase</td>
              <td align="left">Input product</td>
              <td align="left" valign="top" width="82">Output Product</td>
            </tr>
            <tr>
              <td
              style="width: 181px; vertical-align: top; text-align: left;">User
                &amp; Software Requirements (UR, SR)</td>
              <td style="text-align: left;">User requirements elicitation</td>
              <td
              style="width: 180px; vertical-align: top; text-align: left;"><a
                href="srs.html">Software requirements specification</a></td>
            </tr>
            <tr>
              <td
              style="width: 160px; vertical-align: top; text-align: left;">Architectural
                Design (AD)</td>
              <td align="left"><a href="srs.html">Software requirements
                specification</a></td>
              <td align="left" valign="top" width="82"><a
                href="design.html">design</a></td>
            </tr>
            <tr>
              <td align="left" valign="top" width="181">Detailed Design
              (DD)</td>
              <td align="left"><a href="design.html">design</a></td>
              <td align="left" valign="top" width="82">code<br />
                User Manual<br />
              </td>
            </tr>
            <tr>
              <td align="left" valign="top" width="181">Test and
              Transfer(TR)</td>
              <td align="left"><a
                href="file:///Users/acary/Siconos/software/trunk/Docs/Dev/Kernel/qa-plan.html">Quality
                assurance plan</a></td>
              <td align="left" valign="top" width="82">Quality report<br />
              </td>
            </tr>
            <tr>
              <td align="left" valign="top" width="181">Operations and
                maintenance (OM)</td>
              <td align="left"><a href="srs.html">Software requirements
                specification</a><br />
                <a href="qa-plan.html">Quality assurance plan</a><br />
              </td>
              <td align="left" valign="top" width="82">Project history
                document</td>
            </tr>
          </tbody>
        </table>
        <a name="Tab:IO-Products"></a></div>
      </td>
    </tr>
  </tbody>
</table>
</div>
<br />


<p>Because the developing staff is small, and in order to maintain the best
consistency as possible in the documentation, the number of project documents
is reduced in regard to <a href="glossary.html#ESA">ESA</a> software
engineering guides recommendations :</p>
<ul>
  <li>The users requirements and software requirements are joined in a common
    document for all modules of the platform, the <a href="srs.html">Software
    requirements specification</a> document</li>
  <li>Every project management, quality process data, and testing plans are
    joined in a common document <a href="qa-plan.html">Quality Assurance
    plan</a></li>
  <li>Quality and testing reports are both in the Quality report<br />
  </li>
</ul>

<h5><a name="SECTION00331300000000000000">Global life cycle</a></h5>

<p>The incremental delivery approach, shown in Figure <a
href="file:qa-plan.html#Fig:Icycle">2.1</a>, is characterized by splitting
the DD, TR and OM phases into a number of more manageable units, once the
complete architectural design has been defined. The software is delivered in
multiple releases, each with increased functionality and capability. This may
occurs when certain functions may need to be in place before others can be
effective. <br />
</p>

<div align="center">
<a name="Fig:Icycle"></a><a name="427"></a>

<table style="width: 621px; height: 391px;">
  <caption align="bottom"><strong>Figure 2.1:</strong> Software life-cycle
  and input/output documents according to each phase of development.</caption>
  <tbody>
    <tr>
      <td><img alt="Software Life-Cycle"
        src="figures/incremental_life_cycle.png"
        style="width: 606px; height: 344px;" /><br />
      </td>
    </tr>
  </tbody>
</table>
</div>

<p>During each increment, software requirements and architectural design
documents are reviewed and may be lightly corrected. Detailed design, user
manual and testing plans are completed as the work gradually progresses. <br
/>
</p>

<p>This life-cycle was chosen for this project because the <a
href="glossary.html#Siconos/Kernel">Siconos/Kernel</a> and basic
functionnalities of the platform have to be validated before the development
of specific plugins or of a smart interface. <br />
</p>

<h5><a name="SECTION00331400000000000000">First increment : platform
prototype</a></h5>

<p>This prototype was realized by four students in computer sciences during
their final training course. From January to September 2004, they realized a
complete increment cycle and they considered this first increment as a
complete project development from user requirements elicitation to acceptance
tests. To reach this objective, they used a standard software life-cycle
approach illustrated on figure <a
href="file://qa-plan.html#Fig:Vcycle">2.2</a>. <br />
</p>

<table
style="text-align: left; margin-left: auto; margin-right: auto; width: 621px; height: 391px;">
  <caption align="bottom"><strong>Figure 2.2:</strong> Software life-cycle
  and input/output documents according to each phase of development.</caption>
  <tbody>
    <tr>
      <td style="text-align: center;"><img alt="V Life-Cycle"
        src="figures/Vcycle.png" style="width: 606px; height: 344px;" /><br />
      </td>
    </tr>
  </tbody>
</table>

<p><br />
</p>
<br />


<h4><a name="SECTION00332000000000000000">Methods and Models</a></h4>

<h5><a name="SECTION00332100000000000000">cocomo</a></h5>

<p>This is a cost model for estimating the number of person-months required
to develop software. The model also estimates the development schedule in
months and produces an effort and schedule distribution by major phases. This
model is based on Barry Boehm's accocomo<a name="tex2html4"
href="file://qa-plan.html#foot706"><sup>2.1</sup></a>.Here
is what Boehm says about the model: "Basic COCOMO is good for rough order of
magnitude estimates of software costs, but its accuracy is necessarily
limited because of its lack of factors to account for differences in hardware
constraints, personnel quality and experience, use of modern tools and
techniques, and other project attributes known to have a significant
influence on costs." For more detailed information about cocomo and software
cost estimating in general, I strongly recommend reading Software Engineering
Economics (1981), by Barry Boehm.</p>

<p>The model estimates cost using one of three different development modes:
organic, semidetached and embedded. Here is a summary of how Boehm describes
the modes:</p>
<ul>
  <li>Organic : In the organic mode, relatively small software teams develop
    software in a highly familiar, in-house environment. Most people
    connected with the project have extensive experience in working with
    related systems within the organization, and have a thorough
    understanding of how the system under development will contribute to the
    organizations objectives. Very few organic-mode projects have developed
    products with more than 50 thousand delivered source instructions (KDSI).
    .</li>
  <li>Semidetached: The semidetached mode of software development represents
    an intermediate stage between the organic and embedded modes.
    "Intermediate" may mean either of two things: an intermediate level of
    project characteristic or a mixture of the organic and embedded mode
    characteristics.The size range of a semidetached mode product generally
    extends up to 300 KDSI.</li>
  <li>Embedded : The major distinguishing factor of an embedded-mode software
    project is a need to operate within tight constraints. The product must
    operate within (is embedded in) a strongly coupled complex of hardware,
    software, regulations, and operational procedures, such as an electronic
    funds transfer system or an air traffic control system.</li>
</ul>

<h5>Design method SA/SD method and diagram</h5>
The sd method is an extension to the sa method. This method is based on the
analysis of the data flow to get a first level architecture. Then this
architecture is evaluated and restructured. This is performed in the seven
steps of the methodÂ :
<ol>
  <li>Fundamental diagram</li>
  <li>Refinement of the data flow diagram</li>
  <li>Determination of the kind of diagram</li>
  <li>Plan of the frontier</li>
  <li>First level architecture</li>
  <li>Systematic building of the architecture</li>
  <li>Evaluation and restructuring of the architecture</li>
</ol>
With this method, one can evaluate the cohesion and the links between modules
which is very important for the evolution of the software. This method will
help us to determine the global architecture. In that way we will be able to
design an architecture which will be progressive. The architecture must have
low links between the different modules and have a high cohesion.<br />
The sd diagram is a data flow diagram. It represents the input and output of
information. It also shows the functions, the data storages and the data
flows.

<h5>Models / UML methods and Diagram<br />
</h5>
To build a good architecture of the platform, we will use various modeling
languages and tools. According to the type of information, we want to depict,
the appropriate model to formally represent data, functions, and behaviours
of our system. Among them, we can cite the following diagrams :<a
name="SECTION00332310000000000000"><br />
</a> The uml diagrams are numerous and can modelise lots of relations of the
platform to define an adapted architecture to this platform.
<ul>
  <li>uml diagrams. <br />
    We will use uml tools to create uml diagrams. With uml, we can modelise a
    big part of the architecture with the numerous uml diagrams we will see
    further, and with ocl.
    <ul>
      <li>Sequence diagram <br />
        This diagram shows the links of the different actions we can find in
        the platform. It represents the interactions between the entities of
        the system.</li>
      <li>State diagram <br />
        This diagram aims to represent automatons as state graphs. It shows
        the changes of state of an object or a module in response to the
        interactions.</li>
      <li>Collaboration diagram <br />
        This diagram shows the interactions between the objects (instances of
        classes and actors). It allows to represent the context of an
        interaction.</li>
      <li>Classes diagram <br />
        These diagram are collections of classes which show the structure of
        a model. We use several diagrams for complex models.</li>
    </ul>
  </li>
  <li>ocl <br />
    ocl is a declarative language for describing rules that apply to UML
    models developed at IBM and now part of the UML standard. <br />
    A formal specification language extension to UML. The Object Constraint
    Language is a precise text language that provides constraint and object
    query expressions on an object-oriented model that cannot otherwise be
    expressed by diagrammatic notation. <br />
    OCL supplements UML by providing expressions that have neither the
    ambiguities of natural language nor the inherent difficulty of using
    complex mathematics. <br />
  </li>
</ul>

<h4><a name="SECTION00332400000000000000">Format, style and tools for
documentation and the coding standards</a></h4>
All formats, styles and tools for documentation, and the Coding standards are
defined in the <a
href="file://qa-plan.html">Software
Developpment Methodology</a> <span style="font-weight: bold;"></span><br />


<h3>Work Breakdown structure</h3>
<br />


<div class="todo">
TODO: List tasks that will be needed for this project. Keep dividing tasks
into subtasks until you feel that you have enough detail to expose risks and
make reasonable estimates in ideal engineering hours.</div>

<h4><a name="SECTION00341010000000000000">1000 Software Project
Management</a></h4>
<ul>
  <li>1100 <a href="glossary.html#Siconos/Numerics">Siconos/Numerics</a>
    Management</li>
  <li>1200 <a href="glossary.html#Siconos/Kernel">Siconos/Kernel</a>
    Management</li>
  <li>1300 <a href="glossary.html#Siconos/Analysis">Siconos/Analysis</a>
    Management</li>
  <li>1400 control Management</li>
  <li>1500 imse Management</li>
  <li>1600 Existing softwares and modeling environments review</li>
  <li>1700 Relation with other project (Geoplex, Hycon, DaVinci, ...)</li>
  <li>1800 Studying legal aspects and planning APP deposit</li>
</ul>

<h4><a name="SECTION00341020000000000000">2000</a><a
href="glossary.html#Siconos/Numerics">Siconos/Numerics</a> Software
Production</h4>
<ul>
  <li>2100 Software Specification phase SSD (Software Requirement and
    Architectural Design phase)
    <ul>
      <li>2110 First Increment Production
        <ul>
          <li>2111 Global requirements elicitation</li>
          <li>2112 Partitionning of the whole requirements into sets of
            functionalities</li>
          <li>2113 Definition of the priority between sets and of those
            indispensable</li>
          <li>2114 Definition of some ``minimal'' requirements for a given
          set</li>
          <li>2115 Definition of storage method for matrices</li>
          <li>2116 ssd draft</li>
          <li>2117 ssd final version
            <ul>
              <li>2117.1 Global functionalities of the sets</li>
              <li>2117.2 Data input and output</li>
              <li>2117.3 Interface with C++</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>2120 Second Increment Production
        <ul>
          <li>2121 Inclusion of new sets</li>
          <li>2122 SciLab Toolbox</li>
        </ul>
      </li>
      <li>2130 Third Increment Production
        <ul>
          <li>2131 Enhancement of included sets
            <ul>
              <li>2131.1 Adding some specific storage method for matrices</li>
              <li>2131.2 Adding some specific functionalities</li>
              <li>2131.3 Tuning existing functionnalities for computation
                performance.</li>
            </ul>
          </li>
          <li>2132 Interface with other langages (Fortran9x, Python, ...)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>2200 Detailed Design phase
    <ul>
      <li>2210 First Increment Production
        <ul>
          <li>2211 ddd<a
            href="glossary.html#Siconos/Numerics">Siconos/Numerics</a> for
            the first increment sets
            <ul>
              <li>2211.1 Data Storage descriptions</li>
              <li>2211.2 Detailled interface of functions</li>
              <li>2211.3 Linear Algebra pack</li>
              <li>2211.4 NSS pack</li>
            </ul>
          </li>
          <li>2212 Interface with C++</li>
          <li>2213 Unit Testing
            <ul>
              <li>2213.1 Problem examples</li>
            </ul>
          </li>
          <li>2214 sum<a
            href="glossary.html#Siconos/Numerics">Siconos/Numerics</a> for
            the first increment sets</li>
        </ul>
      </li>
      <li>2220 Second Increment Production
        <ul>
          <li>2221 Inclusion of new sets: ode pack, root finding</li>
          <li>2222 SciLab Toolbox</li>
        </ul>
      </li>
      <li>2230 Third Increment Production
        <ul>
          <li>2231 Sparse storage method for matrices</li>
          <li>2232 Linear Algebra pack for sparse matrices</li>
          <li>2233 Integration of ATLAS</li>
          <li>2234 Block Sparse storage method for matrices</li>
          <li>2235 NSS pack for block sparse matrices</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>2300 Transfer phase Acceptance testing
    <ul>
      <li>2310 First Increment Acceptance testing
        <ul>
          <li>2311 Acceptance test suite</li>
        </ul>
      </li>
      <li>2320 Second Increment Acceptance testing</li>
      <li>2330 Third Increment Acceptance testing</li>
    </ul>
  </li>
</ul>

<h4><a name="SECTION00341030000000000000">3000 Platform kernel:
Siconos/Engine Siconos/Front-End Software Production</a></h4>
<ul>
  <li>3100 Software Requirements phase
    <ul>
      <li>3110 First Increment Production
        <ul>
          <li>3111 Requirements elicitation</li>
          <li>3112 Prototyping and Logical Model</li>
          <li>3113 srd draft</li>
          <li>3114 srd final</li>
        </ul>
      </li>
      <li>3120 Second Increment Production
        <ul>
          <li>3121 Update srd according to academical users feedback</li>
        </ul>
      </li>
      <li>3130 Third Increment Production
        <ul>
          <li>3131 Update srd according to industrial users feedback</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3200 External Specification phase
    <ul>
      <li>3210 First Increment Production
        <ul>
          <li>3211 Describing software using context</li>
          <li>3212 Specifying Interfaces</li>
          <li>3213 Input/Output data description</li>
          <li>3214 Error Cases</li>
        </ul>
      </li>
      <li>3220 Second Increment Production
        <ul>
          <li>3221 Precising using context and the categories of users.</li>
          <li>3222 Definition and Specification of user interfaces, and tools
            for their implementation
            <ul>
              <li>3222.1 End-user Interface : Scilab interface</li>
              <li>3222.2 Expert-user Interface : Python interface</li>
            </ul>
          </li>
          <li>3223 Precise definition for data input/output
            <ul>
              <li>3223.1 XML Input/Output</li>
              <li>3223.2 Expert-user Interface for data</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>3230 Third Increment Production (<a
        href="glossary.html#TBC">TBC</a>)</li>
      <li>3231 Definition of error interface
        <ul>
          <li>3231.1 XML database for error messages</li>
          <li>3231.2 Internationalization (?)</li>
        </ul>
        <ul>
          <li>Linking with existing products</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3300 Architectural Design phase
    <ul>
      <li>3310 First Increment Production
        <ul>
          <li>3311 Prototyping and Physical Model</li>
          <li>3312 add draft</li>
          <li>3313 add final
            <ul>
              <li>3313.1 SA/SD method application</li>
              <li>3313.2 Unit descriptions (conceptual class diagrams)</li>
              <li>3313.3 Simulation course (general sequence diagrams)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>3320 Second Increment Production
        <ul>
          <li>3321 Design of user interfaces, and tools for their
            implementation
            <ul>
              <li>3321.1 End-user Interface : Scilab interface</li>
              <li>3321.2 Expert-user Interface : Python interface</li>
            </ul>
          </li>
          <li>3322 Design for data input/output
            <ul>
              <li>3322.1 XML Input/Output</li>
              <li>3322.2 Expert-user Interface for data</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>3330 Third Increment Production (<a
        href="glossary.html#TBC">TBC</a>)
        <ul>
          <li>3331 Design for data input/output
            <ul>
              <li>3331.1 End-user Interface for data</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3400 Detailed Design phase
    <ul>
      <li>3410 First Increment Production
        <ul>
          <li>3411 ddd draft
            <ul>
              <li>3411.1 UML Class Diagram</li>
              <li>3411.2 I/O management : XML, "on the fly" nonsmooth
                dynamical system creation</li>
              <li>3411.3 Software Deliverable Architecture</li>
            </ul>
          </li>
          <li>3412 First version of the code
            <ul>
              <li>3412.1 Model formalisation Unit</li>
              <li>3412.2 Model strategy Unit</li>
              <li>3412.3 XML I/O Unit</li>
              <li>3412.4 Front-end Unit</li>
              <li>3412.5 Numeric tools Unit</li>
            </ul>
          </li>
          <li>3413 Unit Testing
            <ul>
              <li>3413.1 CppUnit tests</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>3420 Second Increment Production
        <ul>
          <li>3421 Application Programing Interface
            <ul>
              <li>3421.2 Python interface</li>
              <li>3421.3 Scilab interface</li>
            </ul>
          </li>
          <li>3422 User Interface Unit
            <ul>
              <li>3421.1 Scilab interface</li>
              <li>3421.2 Python interface</li>
            </ul>
          </li>
          <li>3423 Model Formalisation Unit Production</li>
          <li>3424 Numerical Simulation Unit Production</li>
          <li>3425 LMGC90 Unit Production</li>
          <li>3426 XML schema 1.1 compliance</li>
        </ul>
      </li>
      <li>3430 Third Increment Production <a
      href="glossary.html#TBD">TBD</a></li>
    </ul>
  </li>
  <li>3500 Transfer phase
    <ul>
      <li>3510 automatic configuration (using Autoconf / Automake)</li>
      <li>3520 Portability
        <ul>
          <li>3521 Linux Platform (OS:Red Hat 9, Fedora Core2)</li>
          <li>3522 UNIX Platform (OS:Solaris)</li>
          <li>3523 Windows Platform (OS : Windows 2000/XP, Cygwin
          environment)</li>
        </ul>
      </li>
      <li>3530 Software Transfer Documentation
        <ul>
          <li>3531 Completing Software User Manual</li>
          <li>3532 Installation documentation</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3600 Platform Testing
    <ul>
      <li>3610 First Increment Testing
        <ul>
          <li>3611 Templates systems and Benchmark definition</li>
          <li>3612 Integration and system testing</li>
          <li>3613 Acceptance Testing</li>
        </ul>
      </li>
      <li>3620 Second Increment Testing
        <ul>
          <li>3621 Templates systems and Benchmark definition</li>
          <li>3622 Integration testing</li>
          <li>3623 System Testing</li>
          <li>3624 Acceptance Testing</li>
        </ul>
      </li>
      <li>3630 Third Increment Testing
        <ul>
          <li>3631 Templates systems and Benchmark definition (model plugin
            library)</li>
          <li>3632 Integration testing</li>
          <li>3633 System Testing</li>
          <li>3634 Acceptance Testing</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4><a name="SECTION00341040000000000000">4000</a><a
href="glossary.html#Siconos/Analysis">Siconos/Analysis</a> Software
Production <a href="glossary.html#TBD">TBD</a></h4>
<ul>
  <li>4100 Software requirements phase SRD
    <ul>
      <li>4110 First Increment Production
        <ul>
          <li>4111 Requirements elicitation</li>
          <li>4112 Prototyping and Logical Model</li>
          <li>4113 Anaylys/SRD draft</li>
        </ul>
      </li>
      <li>4120 Second Increment Production
        <ul>
          <li>4121 Update <a
            href="glossary.html#Siconos/Analysis">Siconos/Analysis</a>/SRD
            according to academical users feedback</li>
        </ul>
      </li>
      <li>4130 Third Increment Production
        <ul>
          <li>4131 Update <a
            href="glossary.html#Siconos/Analysis">Siconos/Analysis</a>/SRD
            according to industrial users feedback</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>4200 External Specification phase
    <ul>
      <li>4210 First Increment Production
        <ul>
          <li>4211 Specify software using context</li>
          <li>4212 Specify interfaces</li>
          <li>4213 Input/Output data description</li>
          <li>4214 Error cases</li>
        </ul>
      </li>
      <li>4220 Second Increment Production</li>
      <li>4230 Third Increment Production</li>
    </ul>
  </li>
  <li>4300 Architectural Design phase ADD
    <ul>
      <li>4310 First Increment Production
        <ul>
          <li>4312 Prototyping and Physical Model</li>
          <li>4313 <a
            href="glossary.html#Siconos/Analysis">Siconos/Analysis</a>/ADD
            draft</li>
          <li>4314 <a
            href="glossary.html#Siconos/Analysis">Siconos/Analysis</a>/ADD
            final
            <ul>
              <li>4314.1 SA/SD method application</li>
              <li>4313.2 Unit descriptions</li>
              <li>4314.3 Simuation course</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>4320 Second Increment Production</li>
      <li>4330 Third Increment Production</li>
    </ul>
  </li>
  <li>4400 Detailed design phase
    <ul>
      <li>4410 First Increment Production
        <ul>
          <li>4411 First increments of the anlysis/ADD
            <ul>
              <li>4411.1 Brute-force Bifurcation diagrams</li>
              <li>4411.2 Domain of attraction calculations</li>
            </ul>
          </li>
          <li>4412 First version of the code</li>
        </ul>
      </li>
      <li>4420 Second Increment Production
        <ul>
          <li>4421 Addition to the <a
            href="glossary.html#Siconos/Analysis">Siconos/Analysis</a>/ADD
            <ul>
              <li>4421.1 Location of fixed points</li>
              <li>4421.2 Location of limit cycles</li>
              <li>4421.3 Continuation of fixed points</li>
              <li>4421.4 Continuation of limit cycles</li>
            </ul>
          </li>
          <li>4422 Updated version of the code</li>
        </ul>
      </li>
      <li>4430 Third Increment Production
        <ul>
          <li>4431 Addition to the <a
            href="glossary.html#Siconos/Analysis">Siconos/Analysis</a>/DDD
            <ul>
              <li>4431.1 Location of standard bifurcations of limit
              cycles</li>
              <li>4431.2 Location of nonsmooth bifurcations of limit
              cycles</li>
              <li>4431.3 Continuation of standard bifurcations of limit
              cycles</li>
              <li>4431.4 Continuation of nonsmooth bifurcations of limit
                cycles</li>
            </ul>
          </li>
          <li>4432 Updated version of the code</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>4500 Unit testing
    <ul>
      <li>4510 First Increment Testing
        <ul>
          <li>4511 Template systems and benchmark definitions</li>
          <li>4512 Integration Testing</li>
          <li>4513 System Testing</li>
          <li>4514 Acceptance Testing</li>
        </ul>
      </li>
      <li>4520 Second Increment Testing
        <ul>
          <li>4521 Template systems and benchmark definitions</li>
          <li>4522 Integration Testing</li>
          <li>4523 System Testing</li>
          <li>4524 Acceptance Testing</li>
        </ul>
      </li>
      <li>4530 Third Increment Testing
        <ul>
          <li>4531 Template systems and benchmark definitions</li>
          <li>4532 Integration Testing</li>
          <li>4533 System Testing</li>
          <li>4534 Acceptance Testing</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>4600 Transfer phase Acceptance testing
    <ul>
      <li>4610 First Increment Testing</li>
      <li>4620 Second Increment Testing</li>
      <li>4630 Third Increment Testing</li>
    </ul>
  </li>
</ul>

<h4><a name="SECTION00341050000000000000">5000 Siconos/Control Software
Production</a><a href="glossary.html#TBD">TBD</a></h4>
<ul>
  <li>5100 Software Requirements phase SRD</li>
  <li>5200 Architectural Design phase ADD</li>
  <li>5300 Detailed Design phase</li>
  <li>5400 Unit testing</li>
  <li>5500 Transfer phase Acceptance testing</li>
</ul>

<h4><a name="SECTION00341060000000000000">6000 Siconos/Pre-Post Software
Production</a><a href="glossary.html#TBD">TBD</a></h4>
<ul>
  <li>6100 Software Requirements phase SRD</li>
  <li>6200 Architectural Design phase ADD</li>
  <li>6300 Detailed Design phase</li>
  <li>6400 Unit testing</li>
  <li>6500 Transfer phase Acceptance testing</li>
</ul>
<br />


<h3>Description of the major workpackages</h3>
<br />


<p>In the section above, six work package has been defined. This first work
package, ``<i>1000 Software Project Management</i>'' to the general
management of the project. The last three packages are not yet defined in
details.</p>

<p>We will described, in the following section, the two major work package
which are ``<i>2000 <a
href="glossary.html#Siconos/Numerics">Siconos/Numerics</a> Software
Production</i>'' and ``<i>3000 Platform kernel Siconos/Engine
Siconos/Front-End Software Production</i>''.</p>

<h4><a name="SECTION00342100000000000000">2000</a><a
href="glossary.html#Siconos/Numerics">Siconos/Numerics</a> Software
Production</h4>

<p>According to the numbering convention of the functionalities in the srd,
the increments of software production must contain :</p>
<dl compact="compact">
  <dt>2310 First Increment Production <br />
  </dt>
    <dd>Linear algebra pack : <a
      href="file://features.html#F-1.001">F-1.001</a>;
      <a
      href="file://features.html#F-1.003">F-1.003.1</a>;
      <a
      href="file://features.html#F-1.003">F-1.003.2</a>;
      <a
      href="file://features.html#F-1.010">F-1.010.1</a>;
      <br />
      NSS Pack : <a
      href="file://features.html#F-1.011">F-1.011.1</a>;
      <a
      href="file://features.html#F-1.011">F-1.011.1</a>;
      <a
      href="file://features.html#F-1.011">F-1.011.2</a>;<a
      href="file://features.html#F-1.011">F-1.011.3</a>;<br
      />
      Numerics API C++ interface : <a
      href="file://features.html#F-1.020">F-1.020.1</a>
      <br />
    </dd>
  <dt>2320 Second Increment Production <br />
  </dt>
    <dd>ODE Pack : <a
      href="file://features.html#F-1.012">F-1.012</a>;<br
      />
      MatLab interface : <a
      href="file://features.html#F-1.020">F-1.020.2</a></dd>
  <dt>2330 Third Increment Production <br />
  </dt>
    <dd>Linear algebra pack optimisation : <a
      href="file://features.html#F-1.002">F-1.002</a><br
      />
      Matrices storage methods : <a
      href="file://features.html#F-1.011">F-1.011.4</a>;<br
      />
      Root finding : <a
      href="file://features.html#F-1.013">F-1.013</a><br
      />
      Automatic, analytical and numerical differentiation : <a
      href="file://features.html#F-1.014">F-1.014</a></dd>
</dl>

<p>This work package is realized by the SICONOS/Numerics defined in the
Section <a
href="file://QP/QP/QP.html#Sec:QP-PMP-PO">2.2</a>.
Only S. Nineb, which is a PhD Student hired by the project will work full
time for 6 months on this development. With the other participants, the total
resources for this work package may be estimated around 10 man.month. These
resources are only sufficient for the design and the development of the first
increment. For others increments, it must be planned to hire an other
person.</p>

<h4><a name="SECTION00342200000000000000">3000 Platform kernel Siconos/Engine
Siconos/Front-End Software Production</a></h4>

<p>According to the numbering convention of the functionalities in the srd,
the increments of software production must contain :</p>
<dl compact="compact">
  <dt>3310 First Increment Production  <br />
  </dt>
    <dd>API C++ : <a
      href="file://features.html#F-2.000">F-2.000</a>
      to <a
      href="file://features.html#F-2.005">F-2.006</a>;
      <a href="srs.html#PER-00">PER.00</a> <br />
      XML format : <a
      href="file://features.html#F-2.300">F-2.300</a>
      to <a
      href="file://features.html#F-2.303">F-2.303</a>;
      <br />
      User Plug-in : <a
      href="file://features.html#F-2.200">F-2.200</a>;
      <br />
      Modeling : <a
      href="file://features.html#F-2.010">F-2.010.1</a>;
      <a
      href="file://features.html#F-2.010">F-2.010.2</a>;
      <a
      href="file://features.html#F-2.011">F-2.011.1</a>;<a
      href="file://features.html#F-2.011">F-2.011.3</a>;
      <a
      href="file://features.html#F-2.012">F-2.012.1</a>;
      <a
      href="file://features.html#F-2.012">F-2.012.3</a>;
      <a
      href="file://features.html#F-2.013">F-2.013.1.a</a>;<br
      />
      Simulation : <a
      href="file://features.html#F-2.100">F-2.100</a>;
      <a
      href="file://features.html#F-2.103">F-2.103</a>
      to <a
      href="file://features.html#F-2.106">F-2.106</a>;<br
      />
      <br />
    </dd>
  <dt>3320 Second Increment Production <br />
  </dt>
    <dd>API C : <a
      href="file://features.html#F-3.001">F-3.001</a>;
      <br />
      Interface between the API C and Scilab <a
      href="glossary.html#TBD">TBD</a> <br />
      Interface between the API C++ and Python <a
      href="glossary.html#TBD">TBD</a><br />
      Modeling : <a
      href="file://features.html#F-2.013">F-2.013.2</a>;<br
      />
      Simulation : <a
      href="file://features.html#F-2.101">F-2.101</a><br
      />
      <br />
    </dd>
  <dt>3330 Third Increment Production <br />
  </dt>
</dl>
<dl>
    <dd>Output and Trace values: <a
      href="file://features.html#F-2.304">F-2.304</a><br
      />
    </dd>
</dl>
  <dd>Dedicate Softwares plug-in: <a
    href="file://features.html#F-2.202">F-2.202</a><br
    />
  </dd>
  <dd>The rest of functionalities.<a href="glossary.html#TBD">TBD</a><br />
    <br />
  </dd>
<dl compact="compact">
  <dt><br />
  </dt>
</dl>

<p>This work package is the core of the platform. It is realized by
Frédéric Dubois, Vincent Acary and two software engineers who are hired for
6 month. The total resources for this work package is around 36 man.month.
This will be sufficient to carry out the first and the second increments. To
carry out the third increment, it is planned to hire a software engineener
for the year 2005.</p>

<h3>Schedule and Milestones</h3>
The two following tables present the general planning of SICONOS/WP2.

<table
style="text-align: left; margin-left: auto; margin-right: auto; width: 646px; height: 530px;"
border="1" cellpadding="3">
  <caption align="bottom">Definition of Milestones<br />
  </caption>
  <tbody>
    <tr>
      <td align="left">ID</td>
      <td style="text-align: left;">Desciption of the milestone</td>
      <td align="left">Schedule</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br />
      </td>
      <td style="vertical-align: top;"><br />
      </td>
      <td style="vertical-align: top;"><br />
      </td>
    </tr>
    <tr>
      <td align="left"><i>M1.a</i></td>
      <td align="left"><ul>
          <li> numerics: srs draft and NSS pack</li>
        </ul>
      </td>
      <td align="left">March 2004</td>
    </tr>
    <tr>
      <td align="left"><i>M1.b</i></td>
      <td align="left"><ul>
          <li>srs and design draft of the <a
            href="glossary.html#Siconos/Kernel">Siconos/Kernel</a></li>
        </ul>
      </td>
      <td align="left"><br />
      </td>
    </tr>
    <tr>
      <td align="left"><i>M2.a</i></td>
      <td align="left"><ul>
          <li> First Increment of the <a
            href="glossary.html#Siconos/Kernel">Siconos/Kernel</a> complete
            (code and tests)</li>
        </ul>
      </td>
      <td align="left">June 2004</td>
    </tr>
    <tr>
      <td align="left"><i>M2.b</i></td>
      <td align="left"><ul>
          <li>Documentation and Quality reports</li>
        </ul>
      </td>
      <td align="left">September 2004</td>
    </tr>
    <tr>
      <td align="left"><i>M3.a</i></td>
      <td align="left"><ul>
          <li>Numerics : first increment complete</li>
          <li>Kernel 1 : API C and C++</li>
          <li>Kernel 2 : Numerics integration, Numerical and model
            formalisation</li>
        </ul>
        <br />
      </td>
      <td align="left">January 2005</td>
    </tr>
    <tr>
      <th align="left"><i>M3.b</i></th>
      <td align="left"><ul>
          <li>Numerics : Second increment complete</li>
          <li>Kernel
            <ul>
              <li>Python and Scilab interface, portability</li>
              <li>coupling LMGC90 to the platform</li>
              <li>First Benchmarks and Demonstation examples</li>
            </ul>
          </li>
        </ul>
      </td>
      <td align="left">March 2005</td>
    </tr>
    <tr>
      <td align="left"><i>M4.a</i></td>
      <td align="left"><ul>
          <li> Kernel :
            <ul>
              <li>Third Increment production (model and numerical
                formalization)</li>
              <li>Model Plugin Library (Benchmarks and Demonstation
              examples)</li>
            </ul>
          </li>
          <li>Analysis : Evaluation of the Kernel and Numerics (T1)</li>
        </ul>
      </td>
      <td align="left">June 2005<br />
      </td>
    </tr>
    <tr>
      <td align="left"><i>M4.b</i></td>
      <td align="left"><ul>
          <li>Numerics : Third increment complete</li>
          <li>Kernel : First distribution version with Scilab and Python
            Interfaces</li>
          <li>Analysis : First development increment complete (T2 &amp;
          T3)</li>
        </ul>
      </td>
      <td align="left">September 2005</td>
    </tr>
    <tr>
      <td align="left"><i>M4.c</i></td>
      <td align="left"><ul>
          <li> Analysis : First validation increment complete (E2 &amp;
          E3)</li>
        </ul>
      </td>
      <td align="left">December 2005</td>
    </tr>
    <tr>
      <td align="left"><i>M5</i></td>
      <td align="left"><ul>
          <li>Analysis : Second development increment complete (T4 &amp;
          T5)</li>
          <li>Control : First increment complete <a
            href="glossary.html#TBC">TBC</a></li>
        </ul>
      </td>
      <td align="left">March 2006</td>
    </tr>
    <tr>
      <td align="left"><i>M6</i></td>
      <td align="left"><ul>
          <li>Analysis : Second validation increment complete (E4 &amp; E4
            &amp; E6)</li>
          <li>IMSE : Design and implementation <a
            href="glossary.html#TBC">TBC</a><br />
          </li>
        </ul>
      </td>
      <td align="left">September 2006</td>
    </tr>
  </tbody>
</table>

<h3>Human resources assignment and budget<br />
</h3>
<br />


<div class="todo">
TODO: Recall the human resources and budget. How it has been used actually
?</div>
<br />


<h2>Configuration Management Plan</h2>

<h3>Tool for configuration management : Subversion</h3>
We use <a href="subversion.tigris.org">subversion</a> as a revision control
system. Subversion is an open-source revision control system, which aims to
be a compelling replacement for CVS.<br />


<p>The following rules have to be respected by all users of siconos SVN
server :</p>
<ul>
  <li>WriteÂ  logs in english</li>
  <li>Except very particular cases, commit only sources which succesfully
    compiles (and pass tests for the code). This rule is valid as much for
    documents as source code.</li>
  <li>Correct possible conflicts before committing your work.</li>
  <li>Official documents of WP2 are stored on SVN server.</li>
</ul>

<h3>Documents</h3>
<br />


<p>The documents concerned by this section are official project documents,
such as <a href="srs.html">Software requirements specification</a> and <a
href="design.html">design</a> documents. These documents are written in
english and the last validated version must be downloadable on <a
href="http://gforge.inria.fr/projects/siconos/">Siconos Gforge web site</a>
in a PDF format file. After each major update , a document must be validated
by a team leader and its version number increased. The current version of
these document is available on SVN project server. To get more details about
Documents writing process, see the <a
href="file://qa-plan.html">Software
Development Methodology</a> document.</p>
<br />


<h2>Verification and Validation Plan</h2>
<dl>
</dl>

<h3>Introduction and contents</h3>

<p>The Verification and Validation plan is divided into three phases :</p>
<ol>
  <li><b>Unit testing Plan</b>: In the phase of unit tests, one verify that
    the software subsystems and components work correctly in isolation, and
    as specified in the detailed design (see ddd). The set of unit tests are
    defined for each increment in the section <a
    href="#Unit_testing_plan">Unit testing Plan</a>.</li>
  <li><b>Integration testing plan</b>: In the phase of integration tests, one
    verify that the major software components work correctly with the rest of
    the system, and as specified in the architectural design (see add). The
    set of integration tests are defined for each increment in the section <a
    href="#Integration_testing_plan">Integration testing Plan</a>.</li>
  <li><b>System and Acceptance testing plan</b>: In the phase acceptance
    tests, one verify that the software system meets the user requirements
    (see srd and esd). The set of acceptance tests are defined for each
    increment in the section <a
    href="#System_and_Acceptance_testing_plan">System and Acceptance testing
    Plan</a></li>
</ol>

<p>These verification activities demonstrate compliance specifications. This
may be done by showing that the product: performs as specified; contains no
defects that prevent it performing as specified.</p>

<p>The results of the verification and validation plan will be found in the
qr.</p>

<h3>Organisation of the reviews to meet the plan</h3>
Reviews and meeting are regularly organized to present the work done. People
concerned by these reviews are all the development team members and also the
persons in charge of the development team. <br />


<p>That's the group leader who manages reviews and decides the main goal of
the review.So call-conference are organised between the inria (Grenoble) and
the lmgc (Montpellier). Moreover, meetings are planned in one or the other
city. <br />
</p>

<p>During these reviews, the accomplished work is presented and present
people must have read the new or modified documents.<br />
</p>

<h3><a name="Unit_testing_plan"></a>Unit testing plan</h3>

<h4>Unit test tools<br />
</h4>
The tool used to do the unit tests is <a
href="http://sourceforge.net/projects/cppunit">CppUnit</a>. CppUnit is the
C++ port of the famous JUnit framework for unit testing. It allows to make
test suites on each independant module which must be tested.

<h4>Scope of the Unit test plan</h4>
The following module have been included into the unit test plan :
<ul>
  <li>Each components of the <a
    href="glossary.html#Siconos/Kernel">Siconos/Kernel</a></li>
  <li><a href="glossary.html#Siconos/Numerics">Siconos/Numerics</a></li>
</ul>
For each tested module, the unitary tests have to be performed successfully
before validating changes in the software.

<h4>Objectives</h4>
The aim of these tests is to ensure that all the functions of the tested
module are doing that they have to do and that they are doing that in the
right way. The tests must show that the behaviour of each function is the one
which was expected. The Unitary tests ensures us of the correct functioning
of low level operations that will be used at higher level.

<h4>Satisfaction criterion</h4>
The unitary tests have to ensure :
<ul>
  <li>The reliability (right behaviour of the tested functions)</li>
  <li>The robustness (exception management)</li>
</ul>
These criterion ensure us that basic functions behave as we expect. With
CppUnit, each test suite ends with a summary of the passed and failed tests.
To validate the modifications of the source code, it is required that no test
failed.

<h4>Description of some specific unit tests</h4>

<h5>SiconosMatrix and SiconosVector unitary tests<br />
</h5>
<ol>
  <li>Constructors and destructors : <br />
  </li>
  <li>Comparison operator : <br />
  </li>
  <li>Reading and writing in files : <br />
    A vector and a matrix are saved into a file, then they are read and the
    read values must be equal to the origin values. Binary and ASCII storages
    are tested.</li>
  <li>Add function : <br />
  </li>
  <li>Affectation operator : <br />
  </li>
  <li>"linear solve" function : <br />
  </li>
  <li>Getter and Setter : <br />
  </li>
  <li>Computation operators ( +, -, *, /, ) : <br />
  </li>
  <li>blockMatrixCopy : <br />
    The block matrix must be well copied into the current matrix, wherever it
    is copied. Exception are rose when the copy would have been overflow.</li>
  <li>Exceptions : <br />
  </li>
</ol>

<h5>XML module unitary tests</h5>
<ol>
  <li>Get methods : <br />
    They are the basics operations of the module. For each class of the XML
    management module, getter functions must be able to read data from an xml
    DOM tree. The reading of an XML file give us the way to tests getters and
    setters.</li>
  <li>Access to inherited objects : <br />
    The structure of the XML management module uses inheritance and
    polymorphism. The use of generic classes to store information must allow
    to grant the access to specific class attributes. Tests are trying to
    call specific methods of generic pointer using static casting, and
    polymorphism is tested by calling methods that are not implemented in
    parent class but only in child class.</li>
  <li>Exception management : <br />
    Bad manipulations of data structures have to launch exceptions. Each
    exception which could be launched has to be tested.</li>
  <li>XML toolbox (SiconosDOMTreeTools) : <br />
    Basic XML operations are managed with the SiconosDOMTreeTools "toolbox".
    Access to the DOM tree containing XML data read from an XML file is given
    with SiconosDOMTreeTools functions. These low level methods are very
    important for all the XML management module. Tests consists in
    manipulating the data of the DOM tree. So test suites are reading/writing
    in the DOM tree with getter and setter functions. Also the modification,
    add of new nodes and attributes with specific method are tested, and a
    tool function which transforms a string into a vector of double numbers.
    Alle these functions have to be tested unitarily.</li>
</ol>

<h5><a href="glossary.html#Siconos/Numerics">Siconos/Numerics</a></h5>

<div class="todo">
TODO: Add a list and more detailed descriptio of the unit tests actually
implemented in the <a href="glossary.html#Siconos/Kernel">Siconos/Kernel</a>
and in <a href="glossary.html#Siconos/Numerics">Siconos/Numerics</a></div>

<h3><a name="Integration_testing_plan"></a>Integration testing plan<br />
</h3>

<h4>Introduction</h4>
At first, we must know the software is a scientific computation platform.
It's compouned of two main parts. The first part is made of a formalization
module and a solving strategy one. This part is the intelligence of the
software. In front of that, the second part which manage XML data, has the
same structure that the first part. <br />
The selected integration strategy is a progressive integration by subsystem,
where the subsystems were these defined during the conception. The first
subsystems are the formalization and the solving strategy modules of the
platform. Then all the XML management module has been integrated to the
growing platform. The plugins were added once the platform was built.

<p>This document aims to present the tests done to validate the integration
of the platform. The modules concerned are the formalization, the solving
strategy and the XML management. <br />
This plan will highlight the communications between the various modules, to
check the good unfolding of the communications. <br />
In this document you will find two main parts :</p>
<ul>
  <li>a File part, which defines the development simulation used and the
    satisfaction criteria.</li>
  <li>a Result part, which explain the results of the tests and analyze
  them.</li>
</ul>

<p><br />
<br />
</p>

<h4>Tests file</h4>
These integration tests are done during the development of each module within
the assigned time. They began when the API was complete and when the
development was enough advanced.
<ul style="font-weight: bold;">
  <li>Testing simulation</li>
</ul>
The tests are built to check all the links between modules and that the
communications are well done.<br />

<ul style="font-weight: bold;">
  <li>Satisfaction criterions</li>
</ul>
The tests are validated by the person in charge for the tests and for
quality. They must clearly show that the communication between modules are
established, and the good and complete unfolding of all the tests. The test
suite must test all the ways of communication between the modules. The XML
test file is complete and exhaustive for all the objects the platform manages.
<ul>
  <li><span style="font-weight: bold;">Development of the tests</span>
    <ul>
      <li>Communication tests between simulation an the formalization (Work
        breakdown structure.3611)</li>
      With this test, we verify that the communications between each
      OneStepIntegrator and his DynamicalSystem are well established, and
      like that each OneStepNSProblem is well associated with his
      Interactions. This link is one-way, so we will check thatthe objects of
      the solving strategy module can display the name of the formalization
      module's object which is associated to it.
      <li>Communication tests between the XML management module and the
        remainder of the platform (Work breakdown structure.3611.1, 3611.2,
        3611.3) </li>
      In this test, we check that the reading of an XML inpt file will create
      the link between the XML management module's objects and the
      formalization and solving strategy modules' objects. Indeed, when an
      XML input file is read, all the XML objects are created, and then, the
      other object of the platform must be created. The basement of the
      platform id the "Model" object type. It is a Model that will launch the
      reading of the XML input file. When the XML objects are created, the
      Model will begin to create and link the formalization ad simulation
      objects to the XML objects. We ensure oneself of the exactitude of the
      result by checking the called functions during the unfolding of the
      test. All the methods called will print to the screen their name in a
      log file, so it is easy to see what happen. The resulting data of this
      test consists in a serie of method call that we can compare with the
      XML input data.
      <li>Communication tests between the plateform and the XML management
        module (Work breakdown structure.3611.3) </li>
      In this test, we check that the communications between each object of
      the platform are well done with the XML object associated to it. In
      this way of communication, it correspond to the save of the platform
      data to an XML file. We ensure oneself of the exactitude of the result
      by checking the method called in the log file. Moreover, the XML output
      file must be similar to the input file because no computations have
      been made with the data.
      <li>Communication tests between the platform and these plugins (Work
        breakdown structure.3611.4) <br />
      </li>
      This test must show tht the platform use the methods given with the
      plugins. To do that, we check the log file where the functions of the
      plugins must have made specific outputs.</ul>
  </li>
</ul>
<ul>
</ul>

<h3><a name="System_and_Acceptance_testing_plan"></a>System and Acceptance
testing plan</h3>
<br />


<h4>Introduction</h4>
At first, we must know the software is a scientific computation platform. It
is composed of two main parts. The first part is made of a formalization
module and a solving strategy one. This part is the intelligence of the
software. In front of that, the second part which manage XML data, has the
same structure that the first part. <br />


<p>This document aims to present the tests done to validate the functioning
of the platform. <br />
In this document you will find two main parts :</p>
<ul>
  <li>a File part, which defines the development strategy used and the
    satisfaction criterions.</li>
  <li>a Result part, which explain the results of the tests and analyze
  them.</li>
</ul>

<h4>Tests file</h4>
The acceptance tests have been realized during the development of the plugin
which allowed to simule the fall of a ball on a rigid plan. It is a very
simple example, but it allows to validate the stages order of the simulation,
the functioning of mechanisms for saving and loading xml data as well as the
plugins' mechanism of the platform.
<ul style="font-weight: bold;">
  <li>Testing simulation</li>
</ul>
The test takes place in the following way : we read an input data file; file
written with the moad, then we do computations on the desired number of
steps. The results are validated by the moad.
<ul style="font-weight: bold;">
  <li>Satisfaction criterions</li>
</ul>
The acceptance tests are validated by the person in charge for the tests, for
the quality and by the moad. The acceptance tests are based on the
requirements expressed by the customer in the srd. <br />
The tests detailled in this document are based in the op, which is the
milestone until june 2004.
<ul style="font-weight: bold;">
  <li>Development of the tests (Work breakdown structure.3612)  <br />

    <ul style="font-weight: normal;">
      <li>XML input file (Work breakdown structure.3611.1, 3611.2) </li>
      It consists in the description of 2 Lagrangian systems :a ball and a
      rigid plan. They are represented as <i>Lagrangian Time Invariant
      Dynamic Systems</i>.
      <li>Ball simulation test (Work breakdown structure.3612.1) <br />
      </li>
      For this test, a plugin : BallPLugin.c, has been developped to
      calculate specific functions of this problem (calculation of inertia,
      of the mass and external forces).</ul>
  </li>
</ul>
<ul>
  <ul style="margin-left: 40px;">
  </ul>
</ul>

<p><br />
</p>
<dl>
  <dt><br />
  </dt>
</dl>

<h2>Miscellaneous</h2>
<dl>
  <dt><br />
  </dt>
  <dt>Why is this QA plan needed?</dt>
    <dd>"Quality" refers to all the good things that we would like to see in
      our product. We build a quality product and assure its quality by
      keeping quality in mind all the time and performing the selected
      activities below. Testing is one QA activity, but it is not the best or
      only one, other QA activities include the use of style guides and
      checklists, review meetings, use of analysis tools, and careful quality
      measurements and estimates. A plan is needed to select and coordinate
      all the QA activities.</dd>
</dl>
</div>

<div class="todo">
<a title="pro use case template and example test plan"
href="http://www.readysetpro.com/">professional test plan template</a>.</div>
</div>
</div>
</body>
</html>
